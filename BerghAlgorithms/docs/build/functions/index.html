<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · Bergh Documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Bergh Documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Main-Functions-for-Fans"><span>Main Functions for Fans</span></a></li><li><a class="tocitem" href="#Main-Functions-for-Destackification"><span>Main Functions for Destackification</span></a></li><li><a class="tocitem" href="#Main-Visualization-Functions"><span>Main Visualization Functions</span></a></li><li><a class="tocitem" href="#Helper-Functions-for-Fans"><span>Helper Functions for Fans</span></a></li><li><a class="tocitem" href="#Helper-Functions-for-Stacky-Fans"><span>Helper Functions for Stacky Fans</span></a></li><li><a class="tocitem" href="#Visualization-Helper-Functions"><span>Visualization Helper Functions</span></a></li></ul></li><li><a class="tocitem" href="../contributors/">Contributors</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/nbenabla/destackification/blob/master/BerghAlgorithms/docs/src/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><pre><code class="language-">DocTestSetup = quote
    using BerghAlgorithms
end</code></pre><h2 id="Main-Functions-for-Fans"><a class="docs-heading-anchor" href="#Main-Functions-for-Fans">Main Functions for Fans</a><a id="Main-Functions-for-Fans-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Functions-for-Fans" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.toric_blowup" href="#BerghAlgorithms.toric_blowup"><code>BerghAlgorithms.toric_blowup</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">toric_blowup(::Union{AbstractSet,AbstractVector},::Polymake.BigObjectAllocated,::AbstractVector)

Takes a normal toric variety X, a set s corresponding to a subset of rays of X, and a (optional) polymake vector, v, blow up X at v. If v is not provided, blow up X at the barycenter of s.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 1 2],INPUT_CONES=[[0,1]]);

julia&gt; B=toric_blowup([0,1],X,[1,1]);

julia&gt; B.INPUT_RAYS
pm::Matrix&lt;pm::Rational&gt;
1 0
1 2
1 1

julia&gt; B.INPUT_CONES
pm::IncidenceMatrix&lt;pm::NonSymmetric&gt;
{0 2}
{1 2}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L501-L524">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.makeSimplicial" href="#BerghAlgorithms.makeSimplicial"><code>BerghAlgorithms.makeSimplicial</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">makeSimplicial(::Polymake.BigObjectAllocated)</code></pre><p>Takes in a normal toric variety and returns a simplicial toric variety by subdividing (blowing up) the non-simplicial maximal cones.</p><p>#Examples</p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0;1 1 0;1 0 1;1 1 1],INPUT_CONES=[[0,1,2,3]])

julia&gt; X.SIMPLICIAL
false

julia&gt; makeSimplicial(X).SIMPLICIAL
true

julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0 0;0 1 0 0;0 0 1 0;1 -1 1 0; 1 0 -2 0],INPUT_CONES=[[0,1,2,3],[0,4]])

julia&gt; X.SIMPLICIAL
false

julia&gt; makeSimplicial(X).SIMPLICIAL
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L591-L614">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.makeSmooth" href="#BerghAlgorithms.makeSmooth"><code>BerghAlgorithms.makeSmooth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">makeSmooth(::Polymake.BigObjectAllocated)</code></pre><p>Takes in a normal toric variety X and output a new smooth toric variety by iteratively blowing up. In the language of fans, these blowups are achieved by subdividing non-smooth cones.</p><p>#Examples</p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[4 -1; 0 1],INPUT_CONES=[[0, 1]])

julia&gt; X.SMOOTH_FAN
false

julia&gt; makeSmooth(X).SMOOTH_FAN
true

julia&gt; makeSmooth(X).INPUT_RAYS
pm::Matrix&lt;pm::Rational&gt;
1 -1/4
0 1
1 0

julia&gt;X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0;1 1 0;1 0 1;1 1 1],INPUT_CONES=[[0,1,2,3]])

julia&gt;X.SMOOTH_FAN
false

julia&gt;makeSmooth(X).SMOOTH_FAN
true

julia&gt;makeSmooth(X).INPUT_RAYS
pm::Matrix&lt;pm::Rational&gt;
1 0 0
1 1 0
1 0 1
1 1 1
2 1 1

julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0;0 1 0;0 0 1;0 -1 -1; -1 0 -1; -2 -1 0],INPUT_CONES=[[0,1,2],[0,1,3],[1,3,4],[1,2,4],[2,4,5],[0,2,5],[0,3,5],[3,4,5]])

julia&gt; X.SMOOTH_FAN
false

julia&gt; makeSmooth(X).SMOOTH_FAN
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L656-L701">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.starSubdivision" href="#BerghAlgorithms.starSubdivision"><code>BerghAlgorithms.starSubdivision</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">starSubdivision(::Polymake.BigObjectAllocated,::Array{Int64,1})

Blows up the input fan at the input ray. A wrapper integrating findMinimalCone and toric_blowup.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0 0; 1 0 1 0; 1 1 0 0; 1 1 1 0; 0 0 0 1],INPUT_CONES=[[0,1,2,3,4]]);

julia&gt; starSubdivision(X,[2,1,0,0]).RAYS
pm::Matrix&lt;pm::Rational&gt;
1 0 0 0
1 0 1 0
0 0 0 1
1 1/2 0 0
1 1 0 0
1 1 1 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L1063-L1081">source</a></section></article><h2 id="Main-Functions-for-Destackification"><a class="docs-heading-anchor" href="#Main-Functions-for-Destackification">Main Functions for Destackification</a><a id="Main-Functions-for-Destackification-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Functions-for-Destackification" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.BerghA" href="#BerghAlgorithms.BerghA"><code>BerghAlgorithms.BerghA</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">BerghA(F::StackyFan,D::Array{Int64,1})</code></pre><p>Given a stacky fan F and a vector of booleans D representing the distinguished structure, returns a smooth stacky fan where the distinguished rays are independent.</p><p>The algorithm is adapted from Daniel Bergh&#39;s <a href="https://arxiv.org/abs/1409.5713">paper on destackification</a>. In brief, it identifies non-smooth cones containing at least one distinguished ray, finds interior points in those cones, and subdivides at those points through a series of stacky barycentric subdivisions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">
julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 2 5],INPUT_CONES=[[0,1]]);

julia&gt; F=addStackStructure(X,[1,1]);

julia&gt; stackyWeights(BerghA(F,[1,1]))
[ 5 ,  2 ,  5 ,  10 ]

julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 2 5],INPUT_CONES=[[0,1]]);

julia&gt; F=addStackStructure(X,[1,1]);

julia&gt; stackyWeights(BerghA(F,[1,0]));
[ 5 ,  5 ,  1 ,  2 ,  5 ,  10 ]

julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 2 5],INPUT_CONES=[[0,1]]);

julia&gt; F=addStackStructure(X,[1,1]);

julia&gt; stackyWeights(BerghA(F,[0,1]))
[ 1 ,  5 ,  5 ,  2 ,  5 ,  1 ,  5 ,  10 ]

julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[4 1; 7 9],INPUT_CONES=[[0,1]]);

julia&gt; F=addStackStructure(X,[1,1]);

julia&gt; stackyWeights(BerghA(F,[1,0]))
[ 609 ,  29 ,  1 ,  174 ,  29 ,  1740 ,  1218 ,  58 ,  145 ,  1044 ,  1044 ,  290 ,  290 ,  145 ,  406 ,  348 ,  261 ,  14616 ,  14616 ,  609 ,  3480 ,  870 ,  609 ,  174 ,  609 ,  9744 ,  14616 ,  1218 ,  58 ,  145 ,  435 ,  725 ,  1305 ,  1740 ,  6960 ,  3480 ,  870 ,  3480 ,  58464 ,  6090 ,  3480 ,  1392 ,  696 ,  1044 ,  2088 ,  261 ,  174 ,  261 ,  609 ,  406 ,  609 ,  609 ,  406 ,  609 ,  1218 ,  812 ,  1218 ,  2088 ,  261 ,  1044 ,  1160 ,  1740 ,  1740 ,  870 ,  1305 ,  1305 ,  14616 ,  10440 ,  145 ,  435 ,  609 ,  116 ,  580 ,  290 ,  580 ,  1740 ,  3480 ,  3480 ,  261 ,  522 ,  261 ,  522 ,  522 ,  1218 ,  1218 ,  1218 ,  1218 ,  2436 ,  2436 ,  4176 ,  2088 ,  3480 ,  2610 ,  29232 ,  6090 ,  1218 ,  290 ,  145 ,  290 ,  12180 ,  261 ,  522 ]

julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[323 179; 44 135],INPUT_CONES=[[0,1]]);

julia&gt; F=addStackStructure(X,[1,1]);

julia&gt; stackyWeights(BerghA(F,[1,1]))
[ 491602456800 ,  49160245680 ,  294961474080 ,  468192816 ,  12173013216 ,  73038079296 ,  12173013216 ,  97384105728 ,  73038079296 ,  196640982720 ,  131093988480 ,  156064272 ,  936385632 ,  468192816 ,  196640982720 ,  49160245680 ,  9832049136 ,  292152317184 ,  5899229481600 ,  3932819654400 ,  589922948160 ,  393281965440 ,  12173013216 ,  8115342144 ,  12173013216 ,  5899229481600 ,  589922948160 ,  737403685200 ,  51126655507200 ,  292152317184 ,  51126655507200 ,  5899229481600 ,  5899229481600 ,  589922948160 ,  589922948160 ,  196640982720 ,  2949614740800 ,  5899229481600 ,  294961474080 ,  589922948160 ,  196640982720 ,  589922948160 ,  393281965440 ,  936385632 ,  24346026432 ,  24346026432 ,  11798458963200 ,  1179845896320 ,  737403685200 ,  1474807370400 ,  2949614740800 ,  5899229481600 ,  589922948160 ,  11798458963200 ,  1179845896320 ,  2949614740800 ,  1474807370400 ,  5899229481600 ,  102253311014400 ]

julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 3; 4 5 6; 2 3 1],INPUT_CONES=[[0,1,2]]);

julia&gt; F=addStackStructure(X,[1,1,1]);

julia&gt; stackyWeights(BerghA(F,[1,1,1]))
[ 28 ,  21 ,  84 ,  28 ,  84 ,  84 ,  42 ,  84 ,  168 ]

julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 2; 2 1 1; 5 3 9],INPUT_CONES=[[0,1,2]]);

julia&gt; F=addStackStructure(X,[1,1,1]);

julia&gt; stackyWeights(BerghA(F,[1,1,1]))
[ 4 ,  4 ,  8 ,  4 ,  4 ,  8 ]

julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 4 3; 1 5],INPUT_CONES=[[0,1],[1,2]]);

julia&gt; F=addStackStructure(X,[1,1,1]);

julia&gt; stackyWeights(BerghA(F,[1,1,1]))
[ 4 ,  34 ,  6 ,  68 ,  34 ,  68 ,  34 ,  6 ,  12 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L1341-L1408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.stackyBlowup" href="#BerghAlgorithms.stackyBlowup"><code>BerghAlgorithms.stackyBlowup</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stackyBlowup(::StackyFan,::Array{Int64,1},::Array{Int64,1})

Takes a stacky fan sf, a ray excep, and a cone, and subdivides the stacky fan at the given ray. Crucially, the given cone should be the minimal cone containing the exceptional ray. The cone input should be zero-indexed.</code></pre><p>#examples</p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 1 2],INPUT_CONES=[[0,1]]);

julia&gt; F=addStackStructure(X,[2,3]);

julia&gt; stackyWeights(stackyBlowup(F,[0,1],[1,1]))
[ 2 ,  1 ,  3 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L770-L785">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.BerghC" href="#BerghAlgorithms.BerghC"><code>BerghAlgorithms.BerghC</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">BerghC(::StackyFan,::Array{Int64,1})

Takes a stacky fan and a binary array indicating which rays are divisorial, and runs Daniel Bergh&#39;s algorithm C. This algorithm performs a series of stacky blowups to reduce the maximal divisorial index of the fan, and returns a fan with a maximal divisorial index of 0.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; F=makeStackyFan([1 1 0;1 3 0; 0 0 1],[[0,1,2]],[1,1,5]);
    
julia&gt; H, div = BerghC(F,[0,0,0]);
    
julia&gt; convert(Array{Int64,2},Polymake.common.primitive(H.fan.RAYS))
5×3 Matrix{Int64}:
 1  1  0
 0  0  1
 2  4  5
 1  3  0
 1  2  0

julia&gt; div
Dict{Any, Any} with 5 entries:
  [1, 1, 0] =&gt; 0
  [0, 0, 1] =&gt; 1
  [2, 4, 5] =&gt; 1
  [1, 2, 0] =&gt; 1
  [1, 3, 0] =&gt; 0

julia&gt; F=makeStackyFan([1 0;1 3; 5 17],[[0,1],[1,2]],[1,1,5]);

julia&gt; H, div = BerghC(F,[0,0,0]);

julia&gt; convert(Array{Int64,2},Polymake.common.primitive(H.fan.RAYS))
5×2 Matrix{Int64}:
  1   0
  2   3
  1   3
 13  44
  5  17
julia&gt; div
Dict{Any, Any} with 5 entries:
  [1, 0]   =&gt; 0
  [13, 44] =&gt; 1
  [1, 3]   =&gt; 0
  [2, 3]   =&gt; 1
  [5, 17]  =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/AlgC.jl#L319-L365">source</a></section><section><div><pre><code class="nohighlight">BerghC(::StackyFan,::Dict)

Functions identically to the previous BerghC method, but takes a dictionary that assigns 0 or 1 to the rays of the input fan to indicate divisoriality. In the previous BerghC method, this dictionary is computed.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/AlgC.jl#L406-L411">source</a></section></article><h2 id="Main-Visualization-Functions"><a class="docs-heading-anchor" href="#Main-Visualization-Functions">Main Visualization Functions</a><a id="Main-Visualization-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Visualization-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.showFan" href="#BerghAlgorithms.showFan"><code>BerghAlgorithms.showFan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">showFan(X::Polymake.BigObjectAllocated)

Plots the input fan as a collection of polygons or polyhedra defined by the input rays and the origin via Plots.jl.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0; 1 0 1; 1 1 0; 1 1 1],INPUT_CONES=[[0,1,2,3]]);

julia&gt; showFan(X);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L1792-L1804">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.showStackyFan" href="#BerghAlgorithms.showStackyFan"><code>BerghAlgorithms.showStackyFan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">showStackyFan(::StackyFan;::Bool=true)

Extends the functionality of showFan to stacky fans. If the stackypoints input is set to true, a red dot is shown at the location of each primitive vector multiplied by its stacky weight.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0; 1 0 1; 1 1 0; 1 1 1],INPUT_CONES=[[0,1,2,3]]);

julia&gt; F=addStackStructure(X,[1,2,2,5]);

julia&gt; showStackyFan(F);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L1825-L1839">source</a></section></article><h2 id="Helper-Functions-for-Fans"><a class="docs-heading-anchor" href="#Helper-Functions-for-Fans">Helper Functions for Fans</a><a id="Helper-Functions-for-Fans-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-Functions-for-Fans" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.findBarycenter" href="#BerghAlgorithms.findBarycenter"><code>BerghAlgorithms.findBarycenter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">findBarycenter(::Union{AbstractSet,AbstractVector},::Polymake.BigObjectAllocated)

Takes a normal toric variety X and a set s corresponding to a subset of rays of X, and outputs a polymake vector corresponding to the barycenter of those rays.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0;1 1; 0 1],INPUT_CONES=[[0,1],[1,2]]);

julia&gt; s=[1,2];

julia&gt; findBarycenter(s,X)
pm::Matrix&lt;pm::Integer&gt;
2 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L318-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.convertBool" href="#BerghAlgorithms.convertBool"><code>BerghAlgorithms.convertBool</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">convertBool(::AbstractVector)</code></pre><p>Takes a column vector of boolean values and converts it to a vector of indices marked &#39;true&#39;.</p><p>#Examples</p><pre><code class="language-julia-repl">julia&gt; B=[true,true,false,true]

julia&gt; convertBool(B)
[0, 1, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L409-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.getConeRank" href="#BerghAlgorithms.getConeRank"><code>BerghAlgorithms.getConeRank</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getConeRank(::AbstractMatrix,::AbstractVector)</code></pre><p>Takes a matrix and a vector containing indices corresponding to rows of a matrix, and calculates the rank of the matrix consisting only of those rows.</p><p>#Examples</p><pre><code class="language-julia-repl">julia&gt; v=[1,2]

julia&gt; M=[0 1; 1 1; 1 0]

julia&gt; getConeRank(v,M)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L433-L448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.getDimension" href="#BerghAlgorithms.getDimension"><code>BerghAlgorithms.getDimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getDimension(::Polymake.BigObjectAllocated)</code></pre><p>Returns the ambient dimension of a normal toric variety.</p><p>#Examples</p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0;1 2 0;0 0 1;0 1 0; 1 1 1],INPUT_CONES=[[0,1,2],[0,2,3,4]])

julia&gt; getDimension(X)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L454-L466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.getConeFaces" href="#BerghAlgorithms.getConeFaces"><code>BerghAlgorithms.getConeFaces</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getConeFaces(::Polymake.BigObjectAllocated,::AbstractVector,::AbstractMatrix)</code></pre><p>Takes a fan, its ray matrix, and a vector corresponding to one of its cones, and returns a list of maximal strict faces of that cone.</p><p>#Examples</p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0; 1 1 0; 1 0 1; 1 1 1],INPUT_CONES=[[0,1,2,3]])

julia&gt; getConeFaces(X,[1,2,3,4],Array(X.RAYS))
[[ 1 ,  2 ], [ 1 ,  3 ], [ 3 ,  4 ], [ 2 ,  4 ]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L471-L483">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.slicematrix" href="#BerghAlgorithms.slicematrix"><code>BerghAlgorithms.slicematrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">slicematrix(::AbstractMatrix{&lt;:Number})

Take a two-dimensional matrix and output a list of its row vectors.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A=[1 2; 3 4];

julia&gt; slicematrix(A)
[[ 1 ,  2 ], [ 3 ,  4 ]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L822-L834">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.rowMinors" href="#BerghAlgorithms.rowMinors"><code>BerghAlgorithms.rowMinors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rowMinors(::AbstractMatrix{&lt;:Number},::Union{AbstractSet,AbstractVector})

Identical to slicematrix, except only returns row vectors indexed by a set S.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A=[1 2 3;4 5 6; 7 8 9];

julia&gt; S=Set([1,3]);

julia&gt; rowMinors(A,S)
2×3 LinearAlgebra.Transpose{Int64,Array{Int64,2}}:
 1  2  3
 7  8  9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L839-L855">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.convertIncidenceMatrix" href="#BerghAlgorithms.convertIncidenceMatrix"><code>BerghAlgorithms.convertIncidenceMatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">convertIncidenceMatrix(::Polymake.IncidenceMatrixAllocated{Polymake.NonSymmetric})

Takes a Polymake incidence matrix (e.g., the output of X.MAXIMAL_CONES for a toric variety X) and outputs a list of vectors, with each vector recording the indices marked on a given row of the incidence matrix.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0;1 1; 0 1],INPUT_CONES=[[0,1],[1,2]]);

julia&gt; M=X.MAXIMAL_CONES;

julia&gt; convertIncidenceMatrix(M)
[[ 1 ,  2 ], [ 2 ,  3 ]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L867-L881">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.coneMultiplicity" href="#BerghAlgorithms.coneMultiplicity"><code>BerghAlgorithms.coneMultiplicity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coneMultiplicity(C::Polymake.BigObjectAllocated)

Returns the multiplicity of a polyhedral cone (inputted as a Polymake object): here, the multiplicity is defined as the index of the sublattice generated by the rays of the cone, inside the full integer lattice contained in the linear subspace generated by the edges of the cone.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">
julia&gt; C=Polymake.polytope.Cone(INPUT_RAYS=[1 0; 1 2]);

julia&gt; coneMultiplicity(C)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L899-L912">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.getMultiplicity" href="#BerghAlgorithms.getMultiplicity"><code>BerghAlgorithms.getMultiplicity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getMultiplicity(::Array{Int64,1},::Array{Int64,2})
    
Same functionality as coneMultiplicity, but calculates the cone rays as a subset of the columns of a ray matrix rather than from a Polymake cone object.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; getMultiplicity([1,2],[1 0; 1 2; 1 3])
2       </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L924-L934">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.coneConvert" href="#BerghAlgorithms.coneConvert"><code>BerghAlgorithms.coneConvert</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coneConvert(::abstractVector{Int64},::abstractMatrix{Int64})

Takes a matrix where the columns represent rays, and a list of indices, and forms a Polymake cone object generated by the rays corresponding to those indices.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">
julia&gt; typeof(coneConvert([1, 2, 4],[1 0 0; 0 1 0; 0 0 1; 1 1 1]))
Polymake.BigObjectAllocated</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L946-L958">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.getCones" href="#BerghAlgorithms.getCones"><code>BerghAlgorithms.getCones</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getCones(X::Polymake.BigObjectAllocated)

Returns all the cones of a fan X as a list of lists, with each interior list containing the indices of the rays generating a given cone.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0; 1 1 0; 1 0 1; 1 1 ],INPUT_CONES=[[0,1,2,3]]);

julia&gt; getCones(X)
[[ 0 ,  1 ,  2 ,  3 ], [ 0 ,  1 ], [ 0 ,  2 ], [ 2 ,  3 ], [ 1 ,  3 ], [ 0 ], [ 1 ], [ 2 ], [ 3 ]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L965-L978">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.findFaceContainingRay" href="#BerghAlgorithms.findFaceContainingRay"><code>BerghAlgorithms.findFaceContainingRay</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">findFaceContainingRay(::Polymake.BigObjectAllocated,::Array{Int64, 1})</code></pre><p>Given a cone and a ray, finds a maximal proper face of the cone containing that ray.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; C=Polymake.polytope.Cone(INPUT_RAYS=[1 0 0; 1 0 1; 1 1 0; 1 1 1]);

julia&gt; findFaceContainingRay(C,[1,1,1]).RAYS
pm::Matrix&lt;pm::Rational&gt;
1 0 1
1 1 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L990-L1005">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.findMinimalCone" href="#BerghAlgorithms.findMinimalCone"><code>BerghAlgorithms.findMinimalCone</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">findMinimalCone(::Polymake.BigObjectAllocated,::Array{Int64,1})</code></pre><p>Given a fan and a ray, finds the minimal cone fo the fan containing the ray.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0 0; 1 0 1 0; 1 1 0 0; 1 1 1 0; 0 0 0 1],INPUT_CONES=[[0,1,2,3,4]]);

julia&gt; findMinimalCone(X,[1,2,0,0])
[1, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L1021-L1033">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.convertToIncidence" href="#BerghAlgorithms.convertToIncidence"><code>BerghAlgorithms.convertToIncidence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">convertToIncidence(v::Array{Int64,1},l::Int64)</code></pre><p>Returns a vector of length l, with entries of 1 indexed by v and entries of 0 everywhere else.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; convertToIncidence([2,3,5],6)
[ 0 , 1 , 1 , 0 , 1 , 0 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L1114-L1125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.interiorPoints" href="#BerghAlgorithms.interiorPoints"><code>BerghAlgorithms.interiorPoints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">interiorPoints(::Polymake.BigObjectAllocated)

Finds all interior lattice points contained in the fundamental region of a given cone. When multiple interior lattice points lie along the same ray, only the point closest to the origin is returned. Notably,</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; C=Polymake.polytope.Cone(INPUT_RAYS=[1 2; 2 1]);

julia&gt; interiorPoints(C)
[[ 1 ,  1 ]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L1200-L1213">source</a></section></article><h2 id="Helper-Functions-for-Stacky-Fans"><a class="docs-heading-anchor" href="#Helper-Functions-for-Stacky-Fans">Helper Functions for Stacky Fans</a><a id="Helper-Functions-for-Stacky-Fans-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-Functions-for-Stacky-Fans" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.StackyFan" href="#BerghAlgorithms.StackyFan"><code>BerghAlgorithms.StackyFan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Structure to store information of a stacky fan - this is a fan together with a dictionary assigning stacky values to each ray.</code></pre><p><strong>Properties:</strong></p><p>-&gt; <code>fan</code> - the underlying fan, as a polymake object -&gt; <code>scalars</code> - the array of stacky values -&gt; <code>stacks</code> - a dictionary assigning stacky values to each ray.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L58-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.makeStackyFan" href="#BerghAlgorithms.makeStackyFan"><code>BerghAlgorithms.makeStackyFan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">makeStackyFan(::Array{Int64,2},::Array{Array{Int64,1},1},::Array{Int64,1}))</code></pre><p>Function to generate a stacky fan from a matrix representing rays as row vectors, a vector of vectors representing the rays contained in each cone, and a vector of stacky values to be assigned the rays. The second input should be zero-indexed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; makeStackyFan([1 0; 1 1; 1 2],[[0,1],[1,2]],[2,2,2])
[ 2 ,  2 ,  2 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L86-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.addStackStructure" href="#BerghAlgorithms.addStackStructure"><code>BerghAlgorithms.addStackStructure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">addStackStructure(::Polymake.BigObjectAllocated, ::Array{Int64, 1})</code></pre><p>Function to generate a stacky fan from a given fan and a set of scalars.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 1 1; 1 2],INPUT_CONES=[[0,1],[1,2]]);

julia&gt; stackyWeights(addStackStructure(X,[2,2,2]))
[ 2 ,  2 ,  2 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L115-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.encode" href="#BerghAlgorithms.encode"><code>BerghAlgorithms.encode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">encode(::Union{Polymake.VectorAllocated{Polymake.Rational},Polymake.VectorAllocated{Polymake.Integer},Vector{Int64}})

Internal function that converts a vector, representing a ray in the fan,</code></pre><p>to a string in order to allow for hashing for the dictionary.</p><p>#Examples</p><pre><code class="language-julia-repl">julia&gt; encode([1,0,2,5])
&quot;1,0,2,5&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L140-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.stackyWeights" href="#BerghAlgorithms.stackyWeights"><code>BerghAlgorithms.stackyWeights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stackyWeights(::StackyFan)

Returns a list of the stacky weights of the rays of the given stacky fan with the same order as the rays of the fan.</code></pre><p>#Examples</p><pre><code class="language-julia-repl">julia&gt; F=makeStackyFan([1 0; 1 1; 1 2; 1 3],[[0,1],[1,2],[2,3]],[1,2,3,4]);

julia&gt; stackyWeights(F)
[ 1 ,  2 ,  3 ,  4 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L156-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.getRayStack" href="#BerghAlgorithms.getRayStack"><code>BerghAlgorithms.getRayStack</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getRayStack(::StackyFan, ::Array{Int64, 1})

Get the scalar associated with a ray in the given stacky fan structure.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; F=makeStackyFan([1 0; 1 1; 1 2; 1 3],[[0,1],[1,2],[2,3]],[1,2,3,4]);

julia&gt; getRayStack(F,[1,2])
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L183-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.rootConstruction" href="#BerghAlgorithms.rootConstruction"><code>BerghAlgorithms.rootConstruction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rootConstruction(::StackyFan, ::Array{Int64, 1})</code></pre><p>Given a fan and a set of scalars corresponding to the rays of the fan, performs a root construction on the fan by multiplying the stack scalars by the given values. </p><p>rootConstruction returns a new StackyFan object, and does not modify the input.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">
julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0;1 1 0;1 0 1;1 1 1],INPUT_CONES=[[0,1,2],[1,2,3]]);

julia&gt; SX = StackyFan(X, [2,3,5,7]);

julia&gt; stackyWeights(rootConstruction(SX, [1, 4, 2, 1]))
[ 2 ,  12 ,  10 ,  7 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L200-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.rootConstructionDistinguished" href="#BerghAlgorithms.rootConstructionDistinguished"><code>BerghAlgorithms.rootConstructionDistinguished</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rootConstructionDistinguished(
    ::StackyFan, 
    ::Polymake.Matrix{Polymake.Rational},
    ::Array{Int64, 1})

Given a fan, a set of distinguished rays, and a set of scalars of equal size,</code></pre><p>performs a root construction on the fan on the distinguished rays by multiplying  the stack scalars by the given values.</p><pre><code class="nohighlight">rootConstructionDistinguished returns a new StackyFan object,</code></pre><p>and does not modify the input.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0;1 1 0;1 0 1;1 1 1],INPUT_CONES=[[0,1,2],[1,2,3]]);

julia&gt; SX = StackyFan(X, [2,3,5,7]);

julia&gt; distinguished = X.RAYS[[2,3],:];

julia&gt; stackyWeights(rootConstructionDistinguished(SX, distinguished, [4, 2]))
[ 2 ,  12 ,  10 ,  7 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L264-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.rootConstructionDistinguishedIndices" href="#BerghAlgorithms.rootConstructionDistinguishedIndices"><code>BerghAlgorithms.rootConstructionDistinguishedIndices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rootConstructionDistinguishedIndices(::StackyFan, ::Array{Int64, 1}, ::Array{Int64, 1})

Given a fan, the indices of the distinguished rays in the fan rays (as an incidence matrix), and</code></pre><p>a set of scalars corresponding to the rays of the fan, performs a root  construction on the fan by multiplying the stack scalars by the given values. </p><pre><code class="nohighlight">rootConstructionDistinguishedIndices returns a new StackyFan object,</code></pre><p>and does not modify the input.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0;1 1 0;1 0 1;1 1 1],INPUT_CONES=[[0,1,2],[1,2,3]]);

julia&gt; SX = StackyFan(X, [2,3,5,7]);

julia&gt; stackyWeights(rootConstructionDistinguishedIndices(SX, [0,1,1,0], [4, 2, 1, 3]))
[ 2 ,  6 ,  5 ,  7 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L228-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.findStackyBarycenter" href="#BerghAlgorithms.findStackyBarycenter"><code>BerghAlgorithms.findStackyBarycenter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">findStackyBarycenter(::Union{AbstractSet,AbstractVector},::StackyFan)

Takes a stacky fan SX and a set s corresponding to a subset of rays of SX, calculates the &#39;stacky rays&#39; corresponding to those rays (the rays times their stacky values), and find the barycenter of the stacky rays.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 1 2],INPUT_CONES=[[0,1]]);

julia&gt; F=addStackStructure(X,[2,3]);

julia&gt; findStackyBarycenter([1,2],F)
[ 5 ,  6 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L357-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.findStackyRayMatrix" href="#BerghAlgorithms.findStackyRayMatrix"><code>BerghAlgorithms.findStackyRayMatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">findStackyRayMatrix(::StackyFan)

Outputs the ray matrix of the given stacky fan, such that each primitive ray is multiplied by its stacky weights.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 2 3; 1 5],INPUT_CONES=[[0,1],[1,2]]);

julia&gt; F=addStackStructure(X,[1,2,3]);

julia&gt; findStackyRayMatrix(F)
3×2 Matrix{Int64}:
 1   0
 4   6
 3  15</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L385-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.getConesPolymake" href="#BerghAlgorithms.getConesPolymake"><code>BerghAlgorithms.getConesPolymake</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getConesPolymake(sf::StackyFan)

Returns a list of cones of a stacky fan, with the cones represented as polymake objects.</code></pre><p>#Examples</p><pre><code class="language-julia-repl">julia&gt; F=makeStackyFan([1 0; 1 1; 1 2; 1 3],[[0,1],[1,2],[2,3]],[1,1,1,1])
    
julia&gt; getConesPolymake(F)[1].RAYS
pm::Matrix&lt;pm::Rational&gt;
1 0
1 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L799-L813">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.distinguishedAndIntPoint" href="#BerghAlgorithms.distinguishedAndIntPoint"><code>BerghAlgorithms.distinguishedAndIntPoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    distinguishedAndIntPoint(::Array{Int64,1},::Array{Int64,2},::Array{Int64,1})

Calculates if the cone formed by a subset of rays in rayMatrix indexed by the entries of cone, and with a distinguished structure given by the incidence vector dist, both contains at least one distinguished ray and contains a proper interior point.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; distinguishedAndIntPoint([1,2,4],[1 0 0; 1 2 0;2 1 3; 1 0 3],[1,0,0,0])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L1089-L1099">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.compareCones" href="#BerghAlgorithms.compareCones"><code>BerghAlgorithms.compareCones</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compareCones(::Array{Int64,1},::Array{Int64,1},::Array{Int64,2},::Array{Int64,1})

Takes in two cones (in index vector notation), a ray matrix, and a incidence vector of distinguished rays. If the cones do not have an equal number of distinguished rays, returns the difference between the two values. Otherwise, returns the difference in the cone multiplicities.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; compareCones([1,2],[2,3],[1 0 0; 0 1 0; 0 0 1],[1,1,0])
1

julia&gt; compareCones([1,2],[1,3],[1 0;1 2;1 -1],[1,1,1])
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L1138-L1152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.extremalCones" href="#BerghAlgorithms.extremalCones"><code>BerghAlgorithms.extremalCones</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">extremalCones(::Array{Array{Int64,1},1},::Array{Int64,2},::Array{Int64,1})

Takes a list of vectors representing cones in a fan, a ray matrix, and a vector representing the distinguished rays as 0 or 1 values, and calculates the cones that are maximal with respect to (first) the number of non-distinguished rays and (second) the multiplicity of the cone. In Bergh&#39;s algorithm A (where this ordering is used), the input S will consist only of those cones containing at least one distinguished ray and at least one interior point.</code></pre><p>#Examples</p><pre><code class="language-julia-repl">julia&gt; extremalCones([[1,2],[2,3],[3,4]],[1 0;1 2; 1 5; 1 8],[0,1,1,0])
[[ 3 ,  4 ]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L1170-L1181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.minimalByLex" href="#BerghAlgorithms.minimalByLex"><code>BerghAlgorithms.minimalByLex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">minimalByLex(::Array{Array{Int64,1},1})

Given a list of vectors of equal length, returns the minimal vector with respect to lexicographic ordering.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A=[[1,1,1],[2,1,3],[0,5,4]];

julia&gt; minimalByLex(A)
[ 0 ,  5 ,  4 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L1251-L1264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.minimalByDist" href="#BerghAlgorithms.minimalByDist"><code>BerghAlgorithms.minimalByDist</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">minimalByDist(::Array{Array{Int64,1},1},::Array{Int64,1})

Given a list of vectors (representing rays as weighted sums of other rays) and a vector of 0&#39;s and 1&#39;s representing non-distinguished and distinguished indices, returns a vector from the list such that the sum of the entries corresponding to distinguished indices is minimized.</code></pre><p>#Examples</p><pre><code class="language-julia-repl">julia&gt; minimalByDist([[0,1,5,7],[3,3,2,2],[8,5,3,6],[2,1,1,10]],[0,1,1,0])
[ 3 , 3 , 2 , 2 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L1283-L1294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.coneRayDecomposition" href="#BerghAlgorithms.coneRayDecomposition"><code>BerghAlgorithms.coneRayDecomposition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coneRayDecomposition(::Array{Int64,1},::Array{Int64,2},::Array{Int64,1},::Array{Int64,1})

This function takes in a cone (a vector of indices of cone generators in rayMatrix), a ray, and a stacky structure for rayMatrix. It first multiplies all generators of the cone by their stacky values, and then finds an expression for the ray as a sum of these stacky generators. The output is a vector of coefficients of the above representation in terms of the rays in rayMatrix, with zeros as coefficients for all rays not in the given cone.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; coneRayDecomposition([1,2,3],[3 5 7; 8 16 9;2 1 3;1 1 1],[2,2,3],[1,1,1,1])
[ 6 ,  5 ,  52 ,  0 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L1308-L1318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.remove!" href="#BerghAlgorithms.remove!"><code>BerghAlgorithms.remove!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">remove!(::Array{Int64},::Int64)

In-place removes a given item from a vector.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A=[1,2,3,4];

julia&gt; remove!(A,1);

julia&gt; A
[2,3,4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/AlgC.jl#L18-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.getIndex" href="#BerghAlgorithms.getIndex"><code>BerghAlgorithms.getIndex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getIndex(::Array{Int64,1},::Array{Int64,2})

Returns the first index at which a vector appears as a row of a matrix.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia">getIndex([0,1,0],[1 0 0; 0 1 0; 0 0 1])
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/AlgC.jl#L37-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.isIndependent" href="#BerghAlgorithms.isIndependent"><code>BerghAlgorithms.isIndependent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isIndependent(::Int64,::Array{Int64,1},::Array{Int64,2})

Takes a ray matrix, a list of indices representing a cone, and an index represeting a ray of that cone. Determines whether the given ray is independent in the cone (i.e. does not contribute to the multiplicity of the cone).</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isIndependent(3,[1,2,3],[1 0 0; 0 1 0; 1 2 3])
false

julia&gt; isIndependent(3,[1,2,3],[1 0 0; 0 1 0; 1 1 1])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/AlgC.jl#L54-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.independencyIndex" href="#BerghAlgorithms.independencyIndex"><code>BerghAlgorithms.independencyIndex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">independencyIndex(::Array{Int64,1},::Array{Int64,2})

Returns the number of non-independent rays in a cone. Input in indices-ray matrix format.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; independencyIndex([1,2,3],[1 0 0 ; 1 2 0; 2 0 3; 0 0 5])
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/AlgC.jl#L79-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.isRelevant" href="#BerghAlgorithms.isRelevant"><code>BerghAlgorithms.isRelevant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isRelevant(::Array{Int64,1},::Array{Int64,1},::StackyFan)

Determines if the given ray, relative to the given cone, either has a stacky value greater than 1 or is not independent.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; F=makeStackyFan([1 0 0; 1 2 0; 0 0 1],[[0,1,2]],[1,1,2]);

julia&gt; isRelevant([1,2,0],[1,2,3],F)
true

julia&gt; F=makeStackyFan([1 0 0; 0 1 0; 0 0 1],[[0,1,2]],[1,1,2]);

julia&gt; isRelevant([0,1,0],[1,2,3],F)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/AlgC.jl#L100-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.toroidalIndex" href="#BerghAlgorithms.toroidalIndex"><code>BerghAlgorithms.toroidalIndex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">toroidalIndex(::Array{Int64,1},::StackyFan,::Dict)

Calculates the toroidal index of the given cone of a divisorial stacky fan, or the number of relevant non-divisorial rays. Compare to divisorialIndex().</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; F=makeStackyFan([1 0 0; 0 1 0; 1 0 2],[[0,1,2]],[1,2,1]);

julia&gt; div=Dict([1,0,0]=&gt;0,[0,1,0]=&gt;0,[1,0,2]=&gt;0);
    
julia&gt; toroidalIndex([1,2,3],F,div)
3
julia&gt; div=Dict([1,0,0]=&gt;0,[0,1,0]=&gt;0,[1,0,2]=&gt;1);
    
julia&gt; toroidalIndex([1,2,3],F,div)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/AlgC.jl#L126-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.divisorialIndex" href="#BerghAlgorithms.divisorialIndex"><code>BerghAlgorithms.divisorialIndex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">divisorialIndex(::Array{Int64,1},::StackyFan,::Dict)

Calculates the divisorial index (defined by Daniel Bergh) of a given cone in a fan with divisorial rays. 
Specifically, takes the subcone consisting of all relevant non-divisorial rays in a cone, and counts the number of rays that are relevant in that subcone.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; F=makeStackyFan([1 0 0; 0 1 0; 1 0 2],[[0,1,2]],[1,2,1]);

julia&gt; div=Dict([1,0,0]=&gt;0,[0,1,0]=&gt;0,[1,0,2]=&gt;0);
    
julia&gt; divisorialIndex([1,2,3],F,div)
3
julia&gt; div=Dict([1,0,0]=&gt;0,[0,1,0]=&gt;0,[1,0,2]=&gt;1);
    
julia&gt; divisorialIndex([1,2,3],F,div)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/AlgC.jl#L167-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.coneContains" href="#BerghAlgorithms.coneContains"><code>BerghAlgorithms.coneContains</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coneContains(::Array{Int64,1},::Array{Int64,1})

Checks whether every index in the first input is also contained in the second input.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; coneContains([1,2,3],[1,2,3,4])
true
julia&gt; coneContains([1,2,5],[1,2,3,4])
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/AlgC.jl#L226-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.minMaxDivisorial" href="#BerghAlgorithms.minMaxDivisorial"><code>BerghAlgorithms.minMaxDivisorial</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">minMaxDivisorial(::StackyFan,::Dict)

Calculates the maximal divisorial index of all cones in a stacky fan. 
Each maximal cone of the fan will contain at most one minimal subcone of maximal divisorial index; a list of such cones is returned.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; F=makeStackyFan([1 2 0;1 3 0; 3 0 1],[[0,1,2]],[1,1,5]);
    
julia&gt; div=Dict([1,2,0]=&gt;0,[1,3,0]=&gt;0,[3,0,1]=&gt;0);
    
julia&gt; minMaxDivisorial(F,div)
[[3]]
    
julia&gt; F=makeStackyFan([1 1 0;1 3 0; 3 0 1],[[0,1,2]],[1,1,5]);

julia&gt; div=Dict([1,1,0]=&gt;0,[1,3,0]=&gt;0,[3,0,1]=&gt;0);
    
julia&gt; minMaxDivisorial(F,div)
[[1,2,3]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/AlgC.jl#L248-L270">source</a></section></article><h2 id="Visualization-Helper-Functions"><a class="docs-heading-anchor" href="#Visualization-Helper-Functions">Visualization Helper Functions</a><a id="Visualization-Helper-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization-Helper-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.plot3dSimpCone" href="#BerghAlgorithms.plot3dSimpCone"><code>BerghAlgorithms.plot3dSimpCone</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plot3dSimpCone(::Array{Array{Int64,1},1})

Give a list of three 3-dimensional vectors, plots the polygon defined by those vectors and the origin via Plots.jl.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; plot3dSimpCone([[1,0,0],[0,1,0],[0,0,1]]);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L1581-L1591">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.plot2dCone" href="#BerghAlgorithms.plot2dCone"><code>BerghAlgorithms.plot2dCone</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plot2dCone(::Array{Array{Int64,1},1})

Given a list of two 2-dimesnional vectors, plots the polygon defined by those vectors and the origin via Plots.jl.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; plot2dCone([[1,0],[0,1]]);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L1620-L1630">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.showSimpFan" href="#BerghAlgorithms.showSimpFan"><code>BerghAlgorithms.showSimpFan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">showSimpFan(X::Polymake.BigObjectAllocated)

Plots the input simplicial fan as a collection of polygons or polyhedra defined by the input rays and the origin via Plots.jl.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 2 5],INPUT_CONES=[[0,1]]);

julia&gt; showSimpFan(X);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L1648-L1660">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.showSimpStackyFan" href="#BerghAlgorithms.showSimpStackyFan"><code>BerghAlgorithms.showSimpStackyFan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">showSimpStackyFan(::StackyFan;::Bool=true)

Extends the functionality of showSimpFan to stacky simplicial fans. If the stackypoints input is set to true, a red dot is shown at the location of each primitive vector multiplied by its stacky weight.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 2 5],INPUT_CONES=[[0,1]]);

julia&gt; F=addStackStructure(X,[1,2]);

julia&gt; showSimpStackyFan(F);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L1680-L1694">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.coneVectorOrder" href="#BerghAlgorithms.coneVectorOrder"><code>BerghAlgorithms.coneVectorOrder</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Examples</strong></p><pre><code class="nohighlight">coneVectorOrder(::Polymake.BigObjectAllocated)

Takes a polyhedral cone in 2 or 3 dimensions and outputs a list of its defining rays, arranged in counterclockwise order around the exterior of the cone.</code></pre><p><strong>Exampels</strong></p><pre><code class="language-julia-repl">julia&gt; C=Polymake.polytope.Cone(INPUT_RAYS=[1 0 0; 1 0 1; 1 1 0; 1 1 1]);

julia&gt; coneVectorOrder(C)
[[1
, 1, 0], [1, 1, 1], [1, 0, 1], [1, 0, 0]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L1727-L1745">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.plot3dCone" href="#BerghAlgorithms.plot3dCone"><code>BerghAlgorithms.plot3dCone</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plot3dCone(::Array{Array{Int64,1},1})

Plots the 3-dimensional cone defined by the given list of rays. The input rays are assumed to be in counterclockwise or clockwise order around the cone; coneVectorOrder() can be used to obtain this ordering from an arbitrary cone.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; plot3dCone([[1,1,0],[1,1,1],[1,0,1],[1,0,0]]);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/44a7f07e6e2c7bd8b62ff2970e0d013c4b53b75f/BerghAlgorithms/src/StackyFan.jl#L1757-L1767">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../contributors/">Contributors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 25 June 2021 14:20">Friday 25 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
