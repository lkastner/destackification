var documenterSearchIndex = {"docs":
[{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"DocTestSetup = quote\r\n    using BerghAlgorithms\r\nend","category":"page"},{"location":"functions/#Main-Functions-for-Fans","page":"Functions","title":"Main Functions for Fans","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"BerghAlgorithms.toric_blowup\r\nBerghAlgorithms.makeSimplicial\r\nBerghAlgorithms.makeSmooth\r\nBerghAlgorithms.starSubdivision","category":"page"},{"location":"functions/#BerghAlgorithms.toric_blowup","page":"Functions","title":"BerghAlgorithms.toric_blowup","text":"toric_blowup(::Union{AbstractSet,AbstractVector},::Polymake.BigObjectAllocated,::AbstractVector)\n\nTakes a normal toric variety X, a set s corresponding to a subset of rays of X, and a (optional) polymake vector, v, blow up X at v. If v is not provided, blow up X at the barycenter of s.\n\nExamples\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 1 2],INPUT_CONES=[[0,1]]);\n\njulia> B=toric_blowup([0,1],X,[1,1]);\n\njulia> B.INPUT_RAYS\npm::Matrix<pm::Rational>\n1 0\n1 2\n1 1\n\njulia> B.INPUT_CONES\npm::IncidenceMatrix<pm::NonSymmetric>\n{0 2}\n{1 2}\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.makeSimplicial","page":"Functions","title":"BerghAlgorithms.makeSimplicial","text":"makeSimplicial(::Polymake.BigObjectAllocated)\n\nTakes in a normal toric variety and returns a simplicial toric variety by subdividing (blowing up) the non-simplicial maximal cones.\n\n#Examples ```jldoctest makeSmoothWithDependencies julia> X=Polymake.fulton.NormalToricVariety(INPUTRAYS=[1 0 0;1 1 0;1 0 1;1 1 1],INPUTCONES=[[0,1,2,3]])\n\njulia> X.SIMPLICIAL false\n\njulia> makeSimplicial(X).SIMPLICIAL true\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUTRAYS=[1 0 0 0;0 1 0 0;0 0 1 0;1 -1 1 0; 1 0 -2 0],INPUTCONES=[[0,1,2,3],[0,4]])\n\njulia> X.SIMPLICIAL false\n\njulia> makeSimplicial(X).SIMPLICIAL true\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.makeSmooth","page":"Functions","title":"BerghAlgorithms.makeSmooth","text":"makeSmooth(::Polymake.BigObjectAllocated)\n\nTakes in a normal toric variety X and output a new smooth toric variety by iteratively blowing up. In the language of fans, these blowups are achieved by subdividing non-smooth cones.\n\n#Examples ```jldoctest makeSmoothWithDependencies julia> X=Polymake.fulton.NormalToricVariety(INPUTRAYS=[4 -1; 0 1],INPUTCONES=[[0, 1]])\n\njulia> X.SMOOTH_FAN false\n\njulia> makeSmooth(X).SMOOTH_FAN true\n\njulia> makeSmooth(X).INPUT_RAYS pm::Matrix<pm::Rational> 1 -1/4 0 1 1 0\n\njulia>X=Polymake.fulton.NormalToricVariety(INPUTRAYS=[1 0 0;1 1 0;1 0 1;1 1 1],INPUTCONES=[[0,1,2,3]])\n\njulia>X.SMOOTH_FAN false\n\njulia>makeSmooth(X).SMOOTH_FAN true\n\njulia>makeSmooth(X).INPUT_RAYS pm::Matrix<pm::Rational> 1 0 0 1 1 0 1 0 1 1 1 1 2 1 1\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUTRAYS=[1 0 0;0 1 0;0 0 1;0 -1 -1; -1 0 -1; -2 -1 0],INPUTCONES=[[0,1,2],[0,1,3],[1,3,4],[1,2,4],[2,4,5],[0,2,5],[0,3,5],[3,4,5]])\n\njulia> X.SMOOTH_FAN false\n\njulia> makeSmooth(X).SMOOTH_FAN true\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.starSubdivision","page":"Functions","title":"BerghAlgorithms.starSubdivision","text":"starSubdivision(::Polymake.BigObjectAllocated,::Array{Int64,1})\n\nBlows up the input fan at the input ray. A wrapper integrating findMinimalCone and toric_blowup.\n\nExamples\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0 0; 1 0 1 0; 1 1 0 0; 1 1 1 0; 0 0 0 1],INPUT_CONES=[[0,1,2,3,4]]);\n\njulia> starSubdivision(X,[2,1,0,0]).RAYS\npm::Matrix<pm::Rational>\n1 0 0 0\n1 0 1 0\n0 0 0 1\n1 1/2 0 0\n1 1 0 0\n1 1 1 0\n\n\n\n\n\n","category":"function"},{"location":"functions/#Main-Functions-for-Destackification","page":"Functions","title":"Main Functions for Destackification","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"BerghAlgorithms.BerghA\r\nBerghAlgorithms.stackyBlowup\r\nBerghAlgorithms.BerghC","category":"page"},{"location":"functions/#BerghAlgorithms.BerghA","page":"Functions","title":"BerghAlgorithms.BerghA","text":"BerghA(F::StackyFan,D::Array{Int64,1})\n\nGiven a stacky fan F and a vector of booleans D representing the distinguished structure, returns a smooth stacky fan where the distinguished rays are independent.\n\nThe algorithm is adapted from Daniel Bergh's paper on destackification. In brief, it identifies non-smooth cones containing at least one distinguished ray, finds interior points in those cones, and subdivides at those points through a series of stacky barycentric subdivisions.\n\nExamples\n\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 2 5],INPUT_CONES=[[0,1]]);\n\njulia> F=addStackStructure(X,[1,1]);\n\njulia> stackyWeights(BerghA(F,[1,1]))\n[ 5 ,  2 ,  5 ,  10 ]\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 2 5],INPUT_CONES=[[0,1]]);\n\njulia> F=addStackStructure(X,[1,1]);\n\njulia> stackyWeights(BerghA(F,[1,0]));\n[ 5 ,  5 ,  1 ,  2 ,  5 ,  10 ]\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 2 5],INPUT_CONES=[[0,1]]);\n\njulia> F=addStackStructure(X,[1,1]);\n\njulia> stackyWeights(BerghA(F,[0,1]))\n[ 1 ,  5 ,  5 ,  2 ,  5 ,  1 ,  5 ,  10 ]\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[4 1; 7 9],INPUT_CONES=[[0,1]]);\n\njulia> F=addStackStructure(X,[1,1]);\n\njulia> stackyWeights(BerghA(F,[1,0]))\n[ 609 ,  29 ,  1 ,  174 ,  29 ,  1740 ,  1218 ,  58 ,  145 ,  1044 ,  1044 ,  290 ,  290 ,  145 ,  406 ,  348 ,  261 ,  14616 ,  14616 ,  609 ,  3480 ,  870 ,  609 ,  174 ,  609 ,  9744 ,  14616 ,  1218 ,  58 ,  145 ,  435 ,  725 ,  1305 ,  1740 ,  6960 ,  3480 ,  870 ,  3480 ,  58464 ,  6090 ,  3480 ,  1392 ,  696 ,  1044 ,  2088 ,  261 ,  174 ,  261 ,  609 ,  406 ,  609 ,  609 ,  406 ,  609 ,  1218 ,  812 ,  1218 ,  2088 ,  261 ,  1044 ,  1160 ,  1740 ,  1740 ,  870 ,  1305 ,  1305 ,  14616 ,  10440 ,  145 ,  435 ,  609 ,  116 ,  580 ,  290 ,  580 ,  1740 ,  3480 ,  3480 ,  261 ,  522 ,  261 ,  522 ,  522 ,  1218 ,  1218 ,  1218 ,  1218 ,  2436 ,  2436 ,  4176 ,  2088 ,  3480 ,  2610 ,  29232 ,  6090 ,  1218 ,  290 ,  145 ,  290 ,  12180 ,  261 ,  522 ]\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[323 179; 44 135],INPUT_CONES=[[0,1]]);\n\njulia> F=addStackStructure(X,[1,1]);\n\njulia> stackyWeights(BerghA(F,[1,1]))\n[ 491602456800 ,  49160245680 ,  294961474080 ,  468192816 ,  12173013216 ,  73038079296 ,  12173013216 ,  97384105728 ,  73038079296 ,  196640982720 ,  131093988480 ,  156064272 ,  936385632 ,  468192816 ,  196640982720 ,  49160245680 ,  9832049136 ,  292152317184 ,  5899229481600 ,  3932819654400 ,  589922948160 ,  393281965440 ,  12173013216 ,  8115342144 ,  12173013216 ,  5899229481600 ,  589922948160 ,  737403685200 ,  51126655507200 ,  292152317184 ,  51126655507200 ,  5899229481600 ,  5899229481600 ,  589922948160 ,  589922948160 ,  196640982720 ,  2949614740800 ,  5899229481600 ,  294961474080 ,  589922948160 ,  196640982720 ,  589922948160 ,  393281965440 ,  936385632 ,  24346026432 ,  24346026432 ,  11798458963200 ,  1179845896320 ,  737403685200 ,  1474807370400 ,  2949614740800 ,  5899229481600 ,  589922948160 ,  11798458963200 ,  1179845896320 ,  2949614740800 ,  1474807370400 ,  5899229481600 ,  102253311014400 ]\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 3; 4 5 6; 2 3 1],INPUT_CONES=[[0,1,2]]);\n\njulia> F=addStackStructure(X,[1,1,1]);\n\njulia> stackyWeights(BerghA(F,[1,1,1]))\n[ 28 ,  21 ,  84 ,  28 ,  84 ,  84 ,  42 ,  84 ,  168 ]\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 2; 2 1 1; 5 3 9],INPUT_CONES=[[0,1,2]]);\n\njulia> F=addStackStructure(X,[1,1,1]);\n\njulia> stackyWeights(BerghA(F,[1,1,1]))\n[ 4 ,  4 ,  8 ,  4 ,  4 ,  8 ]\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 4 3; 1 5],INPUT_CONES=[[0,1],[1,2]]);\n\njulia> F=addStackStructure(X,[1,1,1]);\n\njulia> stackyWeights(BerghA(F,[1,1,1]))\n[ 4 ,  34 ,  6 ,  68 ,  34 ,  68 ,  34 ,  6 ,  12 ]\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.stackyBlowup","page":"Functions","title":"BerghAlgorithms.stackyBlowup","text":"stackyBlowup(::StackyFan,::Array{Int64,1},::Array{Int64,1})\n\nTakes a stacky fan sf, a ray excep, and a cone, and subdivides the stacky fan at the given ray. Crucially, the given cone should be the minimal cone containing the exceptional ray. The cone input should be zero-indexed.\n\n#examples\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 1 2],INPUT_CONES=[[0,1]]);\n\njulia> F=addStackStructure(X,[2,3]);\n\njulia> stackyWeights(stackyBlowup(F,[0,1],[1,1]))\n[ 2 ,  1 ,  3 ]\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.BerghC","page":"Functions","title":"BerghAlgorithms.BerghC","text":"BerghC(::StackyFan,::Array{Int64,1})\n\nTakes a stacky fan and a binary array indicating which rays are divisorial, and runs Daniel Bergh's algorithm C. This algorithm performs a series of stacky blowups to reduce the maximal divisorial index of the fan, and returns a fan with a maximal divisorial index of 0.\n\nExamples\n\njulia> F=makeStackyFan([1 1 0;1 3 0; 0 0 1],[[0,1,2]],[1,1,5]);\n    \njulia> H, div = BerghC(F,[0,0,0]);\n    \njulia> convert(Array{Int64,2},Polymake.common.primitive(H.fan.RAYS))\n5×3 Matrix{Int64}:\n 1  1  0\n 0  0  1\n 2  4  5\n 1  3  0\n 1  2  0\n\njulia> div\nDict{Any, Any} with 5 entries:\n  [1, 1, 0] => 0\n  [0, 0, 1] => 1\n  [2, 4, 5] => 1\n  [1, 2, 0] => 1\n  [1, 3, 0] => 0\n\njulia> F=makeStackyFan([1 0;1 3; 5 17],[[0,1],[1,2]],[1,1,5]);\n\njulia> H, div = BerghC(F,[0,0,0]);\n\njulia> convert(Array{Int64,2},Polymake.common.primitive(H.fan.RAYS))\n5×2 Matrix{Int64}:\n  1   0\n  2   3\n  1   3\n 13  44\n  5  17\njulia> div\nDict{Any, Any} with 5 entries:\n  [1, 0]   => 0\n  [13, 44] => 1\n  [1, 3]   => 0\n  [2, 3]   => 1\n  [5, 17]  => 1\n\n\n\n\n\nBerghC(::StackyFan,::Dict)\n\nFunctions identically to the previous BerghC method, but takes a dictionary that assigns 0 or 1 to the rays of the input fan to indicate divisoriality. In the previous BerghC method, this dictionary is computed.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Main-Visualization-Functions","page":"Functions","title":"Main Visualization Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"BerghAlgorithms.showFan\r\nBerghAlgorithms.showStackyFan","category":"page"},{"location":"functions/#BerghAlgorithms.showFan","page":"Functions","title":"BerghAlgorithms.showFan","text":"showFan(X::Polymake.BigObjectAllocated)\n\nPlots the input fan as a collection of polygons or polyhedra defined by the input rays and the origin via Plots.jl.\n\nExamples\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0; 1 0 1; 1 1 0; 1 1 1],INPUT_CONES=[[0,1,2,3]]);\n\njulia> showFan(X);\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.showStackyFan","page":"Functions","title":"BerghAlgorithms.showStackyFan","text":"showStackyFan(::StackyFan;::Bool=true)\n\nExtends the functionality of showFan to stacky fans. If the stackypoints input is set to true, a red dot is shown at the location of each primitive vector multiplied by its stacky weight.\n\nExamples\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0; 1 0 1; 1 1 0; 1 1 1],INPUT_CONES=[[0,1,2,3]]);\n\njulia> F=addStackStructure(X,[1,2,2,5]);\n\njulia> showStackyFan(F);\n\n\n\n\n\n","category":"function"},{"location":"functions/#Helper-Functions-for-Fans","page":"Functions","title":"Helper Functions for Fans","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"BerghAlgorithms.findBarycenter\r\nBerghAlgorithms.convertBool\r\nBerghAlgorithms.getConeRank\r\nBerghAlgorithms.getDimension\r\nBerghAlgorithms.getConeFaces\r\nBerghAlgorithms.slicematrix\r\nBerghAlgorithms.rowMinors\r\nBerghAlgorithms.convertIncidenceMatrix\r\nBerghAlgorithms.coneMultiplicity\r\nBerghAlgorithms.getMultiplicity\r\nBerghAlgorithms.coneConvert\r\nBerghAlgorithms.getCones\r\nBerghAlgorithms.findFaceContainingRay\r\nBerghAlgorithms.findMinimalCone\r\nBerghAlgorithms.convertToIncidence\r\nBerghAlgorithms.interiorPoints","category":"page"},{"location":"functions/#BerghAlgorithms.findBarycenter","page":"Functions","title":"BerghAlgorithms.findBarycenter","text":"findBarycenter(::Union{AbstractSet,AbstractVector},::Polymake.BigObjectAllocated)\n\nTakes a normal toric variety X and a set s corresponding to a subset of rays of X, and outputs a polymake vector corresponding to the barycenter of those rays.\n\nExamples\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0;1 1; 0 1],INPUT_CONES=[[0,1],[1,2]]);\n\njulia> s=[1,2];\n\njulia> findBarycenter(s,X)\npm::Matrix<pm::Integer>\n2 1\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.convertBool","page":"Functions","title":"BerghAlgorithms.convertBool","text":"convertBool(::AbstractVector)\n\nTakes a column vector of boolean values and converts it to a vector of indices marked 'true'.\n\n#Examples ```jldoctest makeSmoothWithDependencies julia> B=[true,true,false,true]\n\njulia> convertBool(B) [0, 1, 3]\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.getConeRank","page":"Functions","title":"BerghAlgorithms.getConeRank","text":"getConeRank(::AbstractMatrix,::AbstractVector)\n\nTakes a matrix and a vector containing indices corresponding to rows of a matrix, and calculates the rank of the matrix consisting only of those rows.\n\n#Examples ```jldoctest makeSmoothWithDependencies julia> v=[1,2]\n\njulia> M=[0 1; 1 1; 1 0]\n\njulia> getConeRank(v,M) 2\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.getDimension","page":"Functions","title":"BerghAlgorithms.getDimension","text":"getDimension(::Polymake.BigObjectAllocated)\n\nReturns the ambient dimension of a normal toric variety.\n\n#Examples ```jldoctest makeSmoothWithDependencies julia> X=Polymake.fulton.NormalToricVariety(INPUTRAYS=[1 0 0;1 2 0;0 0 1;0 1 0; 1 1 1],INPUTCONES=[[0,1,2],[0,2,3,4]])\n\njulia> getDimension(X) 3\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.getConeFaces","page":"Functions","title":"BerghAlgorithms.getConeFaces","text":"getConeFaces(::Polymake.BigObjectAllocated,::AbstractVector,::AbstractMatrix)\n\nTakes a fan, its ray matrix, and a vector corresponding to one of its cones, and returns a list of maximal strict faces of that cone.\n\n#Examples ```jldoctest makeSmoothWithDependencies julia> X=Polymake.fulton.NormalToricVariety(INPUTRAYS=[1 0 0; 1 1 0; 1 0 1; 1 1 1],INPUTCONES=[[0,1,2,3]])\n\njulia> getConeFaces(X,[1,2,3,4],Array(X.RAYS)) [[ 1 ,  2 ], [ 1 ,  3 ], [ 3 ,  4 ], [ 2 ,  4 ]]\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.slicematrix","page":"Functions","title":"BerghAlgorithms.slicematrix","text":"slicematrix(::AbstractMatrix{<:Number})\n\nTake a two-dimensional matrix and output a list of its row vectors.\n\nExamples\n\njulia> A=[1 2; 3 4];\n\njulia> slicematrix(A)\n[[ 1 ,  2 ], [ 3 ,  4 ]]\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.rowMinors","page":"Functions","title":"BerghAlgorithms.rowMinors","text":"rowMinors(::AbstractMatrix{<:Number},::Union{AbstractSet,AbstractVector})\n\nIdentical to slicematrix, except only returns row vectors indexed by a set S.\n\nExamples\n\njulia> A=[1 2 3;4 5 6; 7 8 9];\n\njulia> S=Set([1,3]);\n\njulia> rowMinors(A,S)\n2×3 LinearAlgebra.Transpose{Int64,Array{Int64,2}}:\n 1  2  3\n 7  8  9\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.convertIncidenceMatrix","page":"Functions","title":"BerghAlgorithms.convertIncidenceMatrix","text":"convertIncidenceMatrix(::Polymake.IncidenceMatrixAllocated{Polymake.NonSymmetric})\n\nTakes a Polymake incidence matrix (e.g., the output of X.MAXIMAL_CONES for a toric variety X) and outputs a list of vectors, with each vector recording the indices marked on a given row of the incidence matrix.\n\nExamples\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0;1 1; 0 1],INPUT_CONES=[[0,1],[1,2]]);\n\njulia> M=X.MAXIMAL_CONES;\n\njulia> convertIncidenceMatrix(M)\n[[ 1 ,  2 ], [ 2 ,  3 ]]\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.coneMultiplicity","page":"Functions","title":"BerghAlgorithms.coneMultiplicity","text":"coneMultiplicity(C::Polymake.BigObjectAllocated)\n\nReturns the multiplicity of a polyhedral cone (inputted as a Polymake object): here, the multiplicity is defined as the index of the sublattice generated by the rays of the cone, inside the full integer lattice contained in the linear subspace generated by the edges of the cone.\n\nExamples\n\n\njulia> C=Polymake.polytope.Cone(INPUT_RAYS=[1 0; 1 2]);\n\njulia> coneMultiplicity(C)\n2\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.getMultiplicity","page":"Functions","title":"BerghAlgorithms.getMultiplicity","text":"getMultiplicity(::Array{Int64,1},::Array{Int64,2})\n    \nSame functionality as coneMultiplicity, but calculates the cone rays as a subset of the columns of a ray matrix rather than from a Polymake cone object.\n\nExamples\n\njulia> getMultiplicity([1,2],[1 0; 1 2; 1 3])\n2       \n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.coneConvert","page":"Functions","title":"BerghAlgorithms.coneConvert","text":"coneConvert(::abstractVector{Int64},::abstractMatrix{Int64})\n\nTakes a matrix where the columns represent rays, and a list of indices, and forms a Polymake cone object generated by the rays corresponding to those indices.\n\nExamples\n\n\njulia> typeof(coneConvert([1, 2, 4],[1 0 0; 0 1 0; 0 0 1; 1 1 1]))\nPolymake.BigObjectAllocated\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.getCones","page":"Functions","title":"BerghAlgorithms.getCones","text":"getCones(X::Polymake.BigObjectAllocated)\n\nReturns all the cones of a fan X as a list of lists, with each interior list containing the indices of the rays generating a given cone.\n\nExamples\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0; 1 1 0; 1 0 1; 1 1 ],INPUT_CONES=[[0,1,2,3]]);\n\njulia> getCones(X)\n[[ 0 ,  1 ,  2 ,  3 ], [ 0 ,  1 ], [ 0 ,  2 ], [ 2 ,  3 ], [ 1 ,  3 ], [ 0 ], [ 1 ], [ 2 ], [ 3 ]]\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.findFaceContainingRay","page":"Functions","title":"BerghAlgorithms.findFaceContainingRay","text":"findFaceContainingRay(::Polymake.BigObjectAllocated,::Array{Int64, 1})\n\nGiven a cone and a ray, finds a maximal proper face of the cone containing that ray.\n\nExamples\n\njulia> C=Polymake.polytope.Cone(INPUT_RAYS=[1 0 0; 1 0 1; 1 1 0; 1 1 1]);\n\njulia> findFaceContainingRay(C,[1,1,1]).RAYS\npm::Matrix<pm::Rational>\n1 0 1\n1 1 1\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.findMinimalCone","page":"Functions","title":"BerghAlgorithms.findMinimalCone","text":"findMinimalCone(::Polymake.BigObjectAllocated,::Array{Int64,1})\n\nGiven a fan and a ray, finds the minimal cone fo the fan containing the ray.\n\nExamples\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0 0; 1 0 1 0; 1 1 0 0; 1 1 1 0; 0 0 0 1],INPUT_CONES=[[0,1,2,3,4]]);\n\njulia> findMinimalCone(X,[1,2,0,0])\n[1, 3]\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.convertToIncidence","page":"Functions","title":"BerghAlgorithms.convertToIncidence","text":"convertToIncidence(v::Array{Int64,1},l::Int64)\n\nReturns a vector of length l, with entries of 1 indexed by v and entries of 0 everywhere else.\n\nExamples\n\njulia> convertToIncidence([2,3,5],6)\n[ 0 , 1 , 1 , 0 , 1 , 0 ]\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.interiorPoints","page":"Functions","title":"BerghAlgorithms.interiorPoints","text":"interiorPoints(::Polymake.BigObjectAllocated)\n\nFinds all interior lattice points contained in the fundamental region of a given cone. When multiple interior lattice points lie along the same ray, only the point closest to the origin is returned. Notably,\n\nExamples\n\njulia> C=Polymake.polytope.Cone(INPUT_RAYS=[1 2; 2 1]);\n\njulia> interiorPoints(C)\n[[ 1 ,  1 ]]\n\n\n\n\n\n","category":"function"},{"location":"functions/#Helper-Functions-for-Stacky-Fans","page":"Functions","title":"Helper Functions for Stacky Fans","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"BerghAlgorithms.StackyFan\r\nBerghAlgorithms.makeStackyFan\r\nBerghAlgorithms.addStackStructure\r\nBerghAlgorithms.encode\r\nBerghAlgorithms.stackyWeights\r\nBerghAlgorithms.getRayStack\r\nBerghAlgorithms.rootConstruction\r\nBerghAlgorithms.rootConstructionDistinguished\r\nBerghAlgorithms.rootConstructionDistinguishedIndices\r\nBerghAlgorithms.findStackyBarycenter\r\nBerghAlgorithms.findStackyRayMatrix\r\nBerghAlgorithms.getConesPolymake\r\nBerghAlgorithms.distinguishedAndIntPoint\r\nBerghAlgorithms.compareCones\r\nBerghAlgorithms.extremalCones\r\nBerghAlgorithms.minimalByLex\r\nBerghAlgorithms.minimalByDist\r\nBerghAlgorithms.coneRayDecomposition\r\nBerghAlgorithms.remove!\r\nBerghAlgorithms.getIndex\r\nBerghAlgorithms.isIndependent\r\nBerghAlgorithms.independencyIndex\r\nBerghAlgorithms.isRelevant\r\nBerghAlgorithms.toroidalIndex\r\nBerghAlgorithms.divisorialIndex\r\nBerghAlgorithms.coneContains\r\nBerghAlgorithms.minMaxDivisorial","category":"page"},{"location":"functions/#BerghAlgorithms.StackyFan","page":"Functions","title":"BerghAlgorithms.StackyFan","text":"Structure to store information of a stacky fan - this is a fan together with a dictionary assigning stacky values to each ray.\n\nProperties:\n\n-> fan - the underlying fan, as a polymake object -> scalars - the array of stacky values -> stacks - a dictionary assigning stacky values to each ray.\n\n\n\n\n\n","category":"type"},{"location":"functions/#BerghAlgorithms.makeStackyFan","page":"Functions","title":"BerghAlgorithms.makeStackyFan","text":"makeStackyFan(::Array{Int64,2},::Array{Array{Int64,1},1},::Array{Int64,1}))\n\nFunction to generate a stacky fan from a matrix representing rays as row vectors, a vector of vectors representing the rays contained in each cone, and a vector of stacky values to be assigned the rays. The second input should be zero-indexed.\n\nExamples\n\njulia> makeStackyFan([1 0; 1 1; 1 2],[[0,1],[1,2]],[2,2,2])\n[ 2 ,  2 ,  2 ]\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.addStackStructure","page":"Functions","title":"BerghAlgorithms.addStackStructure","text":"addStackStructure(::Polymake.BigObjectAllocated, ::Array{Int64, 1})\n\nFunction to generate a stacky fan from a given fan and a set of scalars.\n\nExamples\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 1 1; 1 2],INPUT_CONES=[[0,1],[1,2]]);\n\njulia> stackyWeights(addStackStructure(X,[2,2,2]))\n[ 2 ,  2 ,  2 ]\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.encode","page":"Functions","title":"BerghAlgorithms.encode","text":"encode(::Union{Polymake.VectorAllocated{Polymake.Rational},Polymake.VectorAllocated{Polymake.Integer},Vector{Int64}})\n\nInternal function that converts a vector, representing a ray in the fan,\n\nto a string in order to allow for hashing for the dictionary.\n\n#Examples\n\njulia> encode([1,0,2,5])\n\"1,0,2,5\"\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.stackyWeights","page":"Functions","title":"BerghAlgorithms.stackyWeights","text":"stackyWeights(::StackyFan)\n\nReturns a list of the stacky weights of the rays of the given stacky fan with the same order as the rays of the fan.\n\n#Examples\n\njulia> F=makeStackyFan([1 0; 1 1; 1 2; 1 3],[[0,1],[1,2],[2,3]],[1,2,3,4]);\n\njulia> stackyWeights(F)\n[ 1 ,  2 ,  3 ,  4 ]\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.getRayStack","page":"Functions","title":"BerghAlgorithms.getRayStack","text":"getRayStack(::StackyFan, ::Array{Int64, 1})\n\nGet the scalar associated with a ray in the given stacky fan structure.\n\nExamples\n\njulia> F=makeStackyFan([1 0; 1 1; 1 2; 1 3],[[0,1],[1,2],[2,3]],[1,2,3,4]);\n\njulia> getRayStack(F,[1,2])\n3\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.rootConstruction","page":"Functions","title":"BerghAlgorithms.rootConstruction","text":"rootConstruction(::StackyFan, ::Array{Int64, 1})\n\nGiven a fan and a set of scalars corresponding to the rays of the fan, performs a root construction on the fan by multiplying the stack scalars by the given values. \n\nrootConstruction returns a new StackyFan object, and does not modify the input.\n\nExamples\n\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0;1 1 0;1 0 1;1 1 1],INPUT_CONES=[[0,1,2],[1,2,3]]);\n\njulia> SX = StackyFan(X, [2,3,5,7]);\n\njulia> stackyWeights(rootConstruction(SX, [1, 4, 2, 1]))\n[ 2 ,  12 ,  10 ,  7 ]\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.rootConstructionDistinguished","page":"Functions","title":"BerghAlgorithms.rootConstructionDistinguished","text":"rootConstructionDistinguished(\n    ::StackyFan, \n    ::Polymake.Matrix{Polymake.Rational},\n    ::Array{Int64, 1})\n\nGiven a fan, a set of distinguished rays, and a set of scalars of equal size,\n\nperforms a root construction on the fan on the distinguished rays by multiplying  the stack scalars by the given values.\n\nrootConstructionDistinguished returns a new StackyFan object,\n\nand does not modify the input.\n\nExamples\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0;1 1 0;1 0 1;1 1 1],INPUT_CONES=[[0,1,2],[1,2,3]]);\n\njulia> SX = StackyFan(X, [2,3,5,7]);\n\njulia> distinguished = X.RAYS[[2,3],:];\n\njulia> stackyWeights(rootConstructionDistinguished(SX, distinguished, [4, 2]))\n[ 2 ,  12 ,  10 ,  7 ]\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.rootConstructionDistinguishedIndices","page":"Functions","title":"BerghAlgorithms.rootConstructionDistinguishedIndices","text":"rootConstructionDistinguishedIndices(::StackyFan, ::Array{Int64, 1}, ::Array{Int64, 1})\n\nGiven a fan, the indices of the distinguished rays in the fan rays (as an incidence matrix), and\n\na set of scalars corresponding to the rays of the fan, performs a root  construction on the fan by multiplying the stack scalars by the given values. \n\nrootConstructionDistinguishedIndices returns a new StackyFan object,\n\nand does not modify the input.\n\nExamples\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0;1 1 0;1 0 1;1 1 1],INPUT_CONES=[[0,1,2],[1,2,3]]);\n\njulia> SX = StackyFan(X, [2,3,5,7]);\n\njulia> stackyWeights(rootConstructionDistinguishedIndices(SX, [0,1,1,0], [4, 2, 1, 3]))\n[ 2 ,  6 ,  5 ,  7 ]\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.findStackyBarycenter","page":"Functions","title":"BerghAlgorithms.findStackyBarycenter","text":"findStackyBarycenter(::Union{AbstractSet,AbstractVector},::StackyFan)\n\nTakes a stacky fan SX and a set s corresponding to a subset of rays of SX, calculates the 'stacky rays' corresponding to those rays (the rays times their stacky values), and find the barycenter of the stacky rays.\n\nExamples\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 1 2],INPUT_CONES=[[0,1]]);\n\njulia> F=addStackStructure(X,[2,3]);\n\njulia> findStackyBarycenter([1,2],F)\n[ 5 ,  6 ]\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.findStackyRayMatrix","page":"Functions","title":"BerghAlgorithms.findStackyRayMatrix","text":"findStackyRayMatrix(::StackyFan)\n\nOutputs the ray matrix of the given stacky fan, such that each primitive ray is multiplied by its stacky weights.\n\nExamples\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 2 3; 1 5],INPUT_CONES=[[0,1],[1,2]]);\n\njulia> F=addStackStructure(X,[1,2,3]);\n\njulia> findStackyRayMatrix(F)\n3×2 Matrix{Int64}:\n 1   0\n 4   6\n 3  15\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.getConesPolymake","page":"Functions","title":"BerghAlgorithms.getConesPolymake","text":"getConesPolymake(sf::StackyFan)\n\nReturns a list of cones of a stacky fan, with the cones represented as polymake objects.\n\n#Examples\n\njulia> F=makeStackyFan([1 0; 1 1; 1 2; 1 3],[[0,1],[1,2],[2,3]],[1,1,1,1])\n    \njulia> getConesPolymake(F)[1].RAYS\npm::Matrix<pm::Rational>\n1 0\n1 1\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.distinguishedAndIntPoint","page":"Functions","title":"BerghAlgorithms.distinguishedAndIntPoint","text":"    distinguishedAndIntPoint(::Array{Int64,1},::Array{Int64,2},::Array{Int64,1})\n\nCalculates if the cone formed by a subset of rays in rayMatrix indexed by the entries of cone, and with a distinguished structure given by the incidence vector dist, both contains at least one distinguished ray and contains a proper interior point.\n\nExamples\n\njulia> distinguishedAndIntPoint([1,2,4],[1 0 0; 1 2 0;2 1 3; 1 0 3],[1,0,0,0])\ntrue\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.compareCones","page":"Functions","title":"BerghAlgorithms.compareCones","text":"compareCones(::Array{Int64,1},::Array{Int64,1},::Array{Int64,2},::Array{Int64,1})\n\nTakes in two cones (in index vector notation), a ray matrix, and a incidence vector of distinguished rays. If the cones do not have an equal number of distinguished rays, returns the difference between the two values. Otherwise, returns the difference in the cone multiplicities.\n\nExamples\n\njulia> compareCones([1,2],[2,3],[1 0 0; 0 1 0; 0 0 1],[1,1,0])\n1\n\njulia> compareCones([1,2],[1,3],[1 0;1 2;1 -1],[1,1,1])\n1\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.extremalCones","page":"Functions","title":"BerghAlgorithms.extremalCones","text":"extremalCones(::Array{Array{Int64,1},1},::Array{Int64,2},::Array{Int64,1})\n\nTakes a list of vectors representing cones in a fan, a ray matrix, and a vector representing the distinguished rays as 0 or 1 values, and calculates the cones that are maximal with respect to (first) the number of non-distinguished rays and (second) the multiplicity of the cone. In Bergh's algorithm A (where this ordering is used), the input S will consist only of those cones containing at least one distinguished ray and at least one interior point.\n\n#Examples\n\njulia> extremalCones([[1,2],[2,3],[3,4]],[1 0;1 2; 1 5; 1 8],[0,1,1,0])\n[[ 3 ,  4 ]]\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.minimalByLex","page":"Functions","title":"BerghAlgorithms.minimalByLex","text":"minimalByLex(::Array{Array{Int64,1},1})\n\nGiven a list of vectors of equal length, returns the minimal vector with respect to lexicographic ordering.\n\nExamples\n\njulia> A=[[1,1,1],[2,1,3],[0,5,4]];\n\njulia> minimalByLex(A)\n[ 0 ,  5 ,  4 ]\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.minimalByDist","page":"Functions","title":"BerghAlgorithms.minimalByDist","text":"minimalByDist(::Array{Array{Int64,1},1},::Array{Int64,1})\n\nGiven a list of vectors (representing rays as weighted sums of other rays) and a vector of 0's and 1's representing non-distinguished and distinguished indices, returns a vector from the list such that the sum of the entries corresponding to distinguished indices is minimized.\n\n#Examples\n\njulia> minimalByDist([[0,1,5,7],[3,3,2,2],[8,5,3,6],[2,1,1,10]],[0,1,1,0])\n[ 3 , 3 , 2 , 2 ]\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.coneRayDecomposition","page":"Functions","title":"BerghAlgorithms.coneRayDecomposition","text":"coneRayDecomposition(::Array{Int64,1},::Array{Int64,2},::Array{Int64,1},::Array{Int64,1})\n\nThis function takes in a cone (a vector of indices of cone generators in rayMatrix), a ray, and a stacky structure for rayMatrix. It first multiplies all generators of the cone by their stacky values, and then finds an expression for the ray as a sum of these stacky generators. The output is a vector of coefficients of the above representation in terms of the rays in rayMatrix, with zeros as coefficients for all rays not in the given cone.\n\nExamples\n\njulia> coneRayDecomposition([1,2,3],[3 5 7; 8 16 9;2 1 3;1 1 1],[2,2,3],[1,1,1,1])\n[ 6 ,  5 ,  52 ,  0 ]\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.remove!","page":"Functions","title":"BerghAlgorithms.remove!","text":"remove!(::Array{Int64},::Int64)\n\nIn-place removes a given item from a vector.\n\nExamples\n\njulia> A=[1,2,3,4];\n\njulia> remove!(A,1);\n\njulia> A\n[2,3,4]\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.getIndex","page":"Functions","title":"BerghAlgorithms.getIndex","text":"getIndex(::Array{Int64,1},::Array{Int64,2})\n\nReturns the first index at which a vector appears as a row of a matrix.\n\nExamples\n\ngetIndex([0,1,0],[1 0 0; 0 1 0; 0 0 1])\n2\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.isIndependent","page":"Functions","title":"BerghAlgorithms.isIndependent","text":"isIndependent(::Int64,::Array{Int64,1},::Array{Int64,2})\n\nTakes a ray matrix, a list of indices representing a cone, and an index represeting a ray of that cone. Determines whether the given ray is independent in the cone (i.e. does not contribute to the multiplicity of the cone).\n\nExamples\n\njulia> isIndependent(3,[1,2,3],[1 0 0; 0 1 0; 1 2 3])\nfalse\n\njulia> isIndependent(3,[1,2,3],[1 0 0; 0 1 0; 1 1 1])\ntrue\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.independencyIndex","page":"Functions","title":"BerghAlgorithms.independencyIndex","text":"independencyIndex(::Array{Int64,1},::Array{Int64,2})\n\nReturns the number of non-independent rays in a cone. Input in indices-ray matrix format.\n\nExamples\n\njulia> independencyIndex([1,2,3],[1 0 0 ; 1 2 0; 2 0 3; 0 0 5])\n2\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.isRelevant","page":"Functions","title":"BerghAlgorithms.isRelevant","text":"isRelevant(::Array{Int64,1},::Array{Int64,1},::StackyFan)\n\nDetermines if the given ray, relative to the given cone, either has a stacky value greater than 1 or is not independent.\n\nExamples\n\njulia> F=makeStackyFan([1 0 0; 1 2 0; 0 0 1],[[0,1,2]],[1,1,2]);\n\njulia> isRelevant([1,2,0],[1,2,3],F)\ntrue\n\njulia> F=makeStackyFan([1 0 0; 0 1 0; 0 0 1],[[0,1,2]],[1,1,2]);\n\njulia> isRelevant([0,1,0],[1,2,3],F)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.toroidalIndex","page":"Functions","title":"BerghAlgorithms.toroidalIndex","text":"toroidalIndex(::Array{Int64,1},::StackyFan,::Dict)\n\nCalculates the toroidal index of the given cone of a divisorial stacky fan, or the number of relevant non-divisorial rays. Compare to divisorialIndex().\n\nExamples\n\njulia> F=makeStackyFan([1 0 0; 0 1 0; 1 0 2],[[0,1,2]],[1,2,1]);\n\njulia> div=Dict([1,0,0]=>0,[0,1,0]=>0,[1,0,2]=>0);\n    \njulia> toroidalIndex([1,2,3],F,div)\n3\njulia> div=Dict([1,0,0]=>0,[0,1,0]=>0,[1,0,2]=>1);\n    \njulia> toroidalIndex([1,2,3],F,div)\n2\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.divisorialIndex","page":"Functions","title":"BerghAlgorithms.divisorialIndex","text":"divisorialIndex(::Array{Int64,1},::StackyFan,::Dict)\n\nCalculates the divisorial index (defined by Daniel Bergh) of a given cone in a fan with divisorial rays. Specifically, takes the subcone consisting of all relevant non-divisorial rays in a cone, and counts the number of rays that are relevant in that subcone.\n\nExamples\n\njulia> F=makeStackyFan([1 0 0; 0 1 0; 1 0 2],[[0,1,2]],[1,2,1]);\n\njulia> div=Dict([1,0,0]=>0,[0,1,0]=>0,[1,0,2]=>0);\n    \njulia> divisorialIndex([1,2,3],F,div)\n3\njulia> div=Dict([1,0,0]=>0,[0,1,0]=>0,[1,0,2]=>1);\n    \njulia> divisorialIndex([1,2,3],F,div)\n1\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.coneContains","page":"Functions","title":"BerghAlgorithms.coneContains","text":"coneContains(::Array{Int64,1},::Array{Int64,1})\n\nChecks whether every index in the first input is also contained in the second input.\n\nExamples\n\njulia> coneContains([1,2,3],[1,2,3,4])\ntrue\njulia> coneContains([1,2,5],[1,2,3,4])\nfalse\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.minMaxDivisorial","page":"Functions","title":"BerghAlgorithms.minMaxDivisorial","text":"minMaxDivisorial(::StackyFan,::Dict)\n\nCalculates the maximal divisorial index of all cones in a stacky fan. Each maximal cone of the fan will contain at most one minimal subcone of maximal divisorial index; a list of such cones is returned.\n\nExamples\n\njulia> F=makeStackyFan([1 2 0;1 3 0; 3 0 1],[[0,1,2]],[1,1,5]);\n    \njulia> div=Dict([1,2,0]=>0,[1,3,0]=>0,[3,0,1]=>0);\n    \njulia> minMaxDivisorial(F,div)\n[[3]]\n    \njulia> F=makeStackyFan([1 1 0;1 3 0; 3 0 1],[[0,1,2]],[1,1,5]);\n\njulia> div=Dict([1,1,0]=>0,[1,3,0]=>0,[3,0,1]=>0);\n    \njulia> minMaxDivisorial(F,div)\n[[1,2,3]]\n\n\n\n\n\n","category":"function"},{"location":"functions/#Visualization-Helper-Functions","page":"Functions","title":"Visualization Helper Functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"BerghAlgorithms.plot3dSimpCone\r\nBerghAlgorithms.plot2dCone\r\nBerghAlgorithms.showSimpFan\r\nBerghAlgorithms.showSimpStackyFan\r\nBerghAlgorithms.coneVectorOrder\r\nBerghAlgorithms.plot3dCone","category":"page"},{"location":"functions/#BerghAlgorithms.plot3dSimpCone","page":"Functions","title":"BerghAlgorithms.plot3dSimpCone","text":"plot3dSimpCone(::Array{Array{Int64,1},1})\n\nGive a list of three 3-dimensional vectors, plots the polygon defined by those vectors and the origin via Plots.jl.\n\nExamples\n\njulia> plot3dSimpCone([[1,0,0],[0,1,0],[0,0,1]]);\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.plot2dCone","page":"Functions","title":"BerghAlgorithms.plot2dCone","text":"plot2dCone(::Array{Array{Int64,1},1})\n\nGiven a list of two 2-dimesnional vectors, plots the polygon defined by those vectors and the origin via Plots.jl.\n\nExamples\n\njulia> plot2dCone([[1,0],[0,1]]);\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.showSimpFan","page":"Functions","title":"BerghAlgorithms.showSimpFan","text":"showSimpFan(X::Polymake.BigObjectAllocated)\n\nPlots the input simplicial fan as a collection of polygons or polyhedra defined by the input rays and the origin via Plots.jl.\n\nExamples\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 2 5],INPUT_CONES=[[0,1]]);\n\njulia> showSimpFan(X);\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.showSimpStackyFan","page":"Functions","title":"BerghAlgorithms.showSimpStackyFan","text":"showSimpStackyFan(::StackyFan;::Bool=true)\n\nExtends the functionality of showSimpFan to stacky simplicial fans. If the stackypoints input is set to true, a red dot is shown at the location of each primitive vector multiplied by its stacky weight.\n\nExamples\n\njulia> X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 2 5],INPUT_CONES=[[0,1]]);\n\njulia> F=addStackStructure(X,[1,2]);\n\njulia> showSimpStackyFan(F);\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.coneVectorOrder","page":"Functions","title":"BerghAlgorithms.coneVectorOrder","text":"Examples\n\nconeVectorOrder(::Polymake.BigObjectAllocated)\n\nTakes a polyhedral cone in 2 or 3 dimensions and outputs a list of its defining rays, arranged in counterclockwise order around the exterior of the cone.\n\nExampels\n\njulia> C=Polymake.polytope.Cone(INPUT_RAYS=[1 0 0; 1 0 1; 1 1 0; 1 1 1]);\n\njulia> coneVectorOrder(C)\n[[1\n, 1, 0], [1, 1, 1], [1, 0, 1], [1, 0, 0]]\n\n\n\n\n\n","category":"function"},{"location":"functions/#BerghAlgorithms.plot3dCone","page":"Functions","title":"BerghAlgorithms.plot3dCone","text":"plot3dCone(::Array{Array{Int64,1},1})\n\nPlots the 3-dimensional cone defined by the given list of rays. The input rays are assumed to be in counterclockwise or clockwise order around the cone; coneVectorOrder() can be used to obtain this ordering from an arbitrary cone.\n\nExamples\n\njulia> plot3dCone([[1,1,0],[1,1,1],[1,0,1],[1,0,0]]);\n\n\n\n\n\n","category":"function"},{"location":"#Destackification","page":"Home","title":"Destackification","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package implements toric stacky fans in Julia by extending the Oscar/Polymake polyhedral fan functionality. In addition to a variety of helper functions for working with stacky fans, several algorithms created by Daniel Bergh are implemented.","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A simple julia struct for polygonal stacky fans, expanding the Oscar/Polymake polyhedral fan struct.\nHelper functions for performing basic operations on stacky fans.\nAlgorithms for blowups, simplicialization, and resolution of singularities on fans, adapted from Macaulay2.\nImplementation of Bergh's destackification algorithms.\nVisualization of stacky fans in two and three dimensions.\n???","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Dan Abramovich, L. Herbert Ballou University Professor, Brown University\nLars Kastner, Postdoctoral Researcher, Institute of Mathematics of the Technical University of Berlin\nStephen Obinna, Graduate Student, Brown University\nNada Benabla, Undergraduate, Brown University\nDhruv Bhatia, Undergraduate, Brown University\nChen Li, Undergraduate, Brown University\nDaniel Li, Undergraduate, Brown University\nDavis Lister, Undergraduate, Brown University\nDanny Silverston, Undergraduate, Brown University\nHenry Talbott, Graduate Student, University of Michigan\nJeremy Wang, Undergraduate, Brown University","category":"page"}]
}
