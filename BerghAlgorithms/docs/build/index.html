<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Destackification · Bergh Documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Bergh Documentation</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Destackification</a><ul class="internal"><li><a class="tocitem" href="#Key-Features"><span>Key Features</span></a></li><li><a class="tocitem" href="#Main-Functions-for-Fans"><span>Main Functions for Fans</span></a></li><li><a class="tocitem" href="#Main-Functions-for-Stacky-Fans"><span>Main Functions for Stacky Fans</span></a></li><li><a class="tocitem" href="#Main-Visualization-Functions"><span>Main Visualization Functions</span></a></li><li><a class="tocitem" href="#Helper-Functions-for-Fans"><span>Helper Functions for Fans</span></a></li><li><a class="tocitem" href="#Helper-Functions-for-Stacky-Fans"><span>Helper Functions for Stacky Fans</span></a></li><li><a class="tocitem" href="#Visualization-Helper-Functions"><span>Visualization Helper Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Destackification</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Destackification</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/nbenabla/destackification/blob/master/BerghAlgorithms/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Destackification"><a class="docs-heading-anchor" href="#Destackification">Destackification</a><a id="Destackification-1"></a><a class="docs-heading-anchor-permalink" href="#Destackification" title="Permalink"></a></h1><p>This package implements toric stacky fans in Julia by extending the Oscar/Polymake polyhedral fan functionality. In addition to a variety of helper functions for working with stacky fans, several <a href="https://arxiv.org/abs/1409.5713">algorithms</a> created by Daniel Bergh are implemented.</p><h2 id="Key-Features"><a class="docs-heading-anchor" href="#Key-Features">Key Features</a><a id="Key-Features-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Features" title="Permalink"></a></h2><ul><li>A simple julia struct for polygonal stacky fans, expanding the Oscar/Polymake polyhedral fan struct.</li><li>Helper functions for performing basic operations on stacky fans.</li><li>Algorithms for blowups, simplicialization, and resolution of singularities on fans, adapted from <a href="http://www2.macaulay2.com/Macaulay2/doc/Macaulay2-1.14/share/doc/Macaulay2/NormalToricVarieties/html/___Normal__Toric__Variety.html">Macaulay2</a>.</li><li>Implementation of Bergh&#39;s destackification algorithms.</li><li>Visualization of stacky fans in two and three dimensions.</li><li>???</li></ul><h2 id="Main-Functions-for-Fans"><a class="docs-heading-anchor" href="#Main-Functions-for-Fans">Main Functions for Fans</a><a id="Main-Functions-for-Fans-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Functions-for-Fans" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.toric_blowup" href="#BerghAlgorithms.toric_blowup"><code>BerghAlgorithms.toric_blowup</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">toric_blowup(::Union{AbstractSet,AbstractVector},::Polymake.BigObjectAllocated,::AbstractVector)

Takes a normal toric variety X, a set s corresponding to a subset of rays of X, and a (optional) polymake vector, v, blow up X at v. If v is not provided, blow up X at the barycenter of s.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 1 2],INPUT_CONES=[[0,1]]);

julia&gt; B=toric_blowup([0,1],X,[1,1]);

julia&gt; B.INPUT_RAYS
pm::Matrix&lt;pm::Rational&gt;
1 0
1 2
1 1

julia&gt; B.INPUT_CONES
pm::IncidenceMatrix&lt;pm::NonSymmetric&gt;
{0 2}
{1 2}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L452-L475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.makeSimplicial" href="#BerghAlgorithms.makeSimplicial"><code>BerghAlgorithms.makeSimplicial</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">makeSimplicial(::Polymake.BigObjectAllocated)</code></pre><p>Takes in a normal toric variety and returns a simplicial toric variety  by subdividing (blowing up) the non-simplicial maximal cones.</p><p>#Examples ```jldoctest makeSmoothWithDependencies julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT<em>RAYS=[1 0 0;1 1 0;1 0 1;1 1 1],INPUT</em>CONES=[[0,1,2,3]])</p><p>julia&gt; X.SIMPLICIAL false</p><p>julia&gt; makeSimplicial(X).SIMPLICIAL true</p><p>julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT<em>RAYS=[1 0 0 0;0 1 0 0;0 0 1 0;1 -1 1 0; 1 0 -2 0],INPUT</em>CONES=[[0,1,2,3],[0,4]])</p><p>julia&gt; X.SIMPLICIAL false</p><p>julia&gt; makeSimplicial(X).SIMPLICIAL true</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L542-L564">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.makeSmooth" href="#BerghAlgorithms.makeSmooth"><code>BerghAlgorithms.makeSmooth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">makeSmooth(::Polymake.BigObjectAllocated)</code></pre><p>Takes in a normal toric variety X and output a new smooth toric variety by iteratively blowing up. In the language of fans, these blowups are achieved by subdividing non-smooth cones.</p><p>#Examples ```jldoctest makeSmoothWithDependencies julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT<em>RAYS=[4 -1; 0 1],INPUT</em>CONES=[[0, 1]])</p><p>julia&gt; X.SMOOTH_FAN false</p><p>julia&gt; makeSmooth(X).SMOOTH_FAN true</p><p>julia&gt; makeSmooth(X).INPUT_RAYS pm::Matrix&lt;pm::Rational&gt; 1 -1/4 0 1 1 0</p><p>julia&gt;X=Polymake.fulton.NormalToricVariety(INPUT<em>RAYS=[1 0 0;1 1 0;1 0 1;1 1 1],INPUT</em>CONES=[[0,1,2,3]])</p><p>julia&gt;X.SMOOTH_FAN false</p><p>julia&gt;makeSmooth(X).SMOOTH_FAN true</p><p>julia&gt;makeSmooth(X).INPUT_RAYS pm::Matrix&lt;pm::Rational&gt; 1 0 0 1 1 0 1 0 1 1 1 1 2 1 1</p><p>julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT<em>RAYS=[1 0 0;0 1 0;0 0 1;0 -1 -1; -1 0 -1; -2 -1 0],INPUT</em>CONES=[[0,1,2],[0,1,3],[1,3,4],[1,2,4],[2,4,5],[0,2,5],[0,3,5],[3,4,5]])</p><p>julia&gt; X.SMOOTH_FAN false</p><p>julia&gt; makeSmooth(X).SMOOTH_FAN true</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L606-L650">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.starSubdivision" href="#BerghAlgorithms.starSubdivision"><code>BerghAlgorithms.starSubdivision</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">starSubdivision(::Polymake.BigObjectAllocated,::Array{Int64,1})

Blows up the input fan at the input ray. A wrapper integrating findMinimalCone and toric_blowup.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0 0; 1 0 1 0; 1 1 0 0; 1 1 1 0; 0 0 0 1],INPUT_CONES=[[0,1,2,3,4]]);

julia&gt; starSubdivision(X,[2,1,0,0]).RAYS
pm::Matrix&lt;pm::Rational&gt;
1 0 0 0
1 0 1 0
0 0 0 1
1 1/2 0 0
1 1 0 0
1 1 1 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L990-L1008">source</a></section></article><h2 id="Main-Functions-for-Stacky-Fans"><a class="docs-heading-anchor" href="#Main-Functions-for-Stacky-Fans">Main Functions for Stacky Fans</a><a id="Main-Functions-for-Stacky-Fans-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Functions-for-Stacky-Fans" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.BerghA" href="#BerghAlgorithms.BerghA"><code>BerghAlgorithms.BerghA</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">BerghA(F::StackyFan,D::Array{Int64,1})</code></pre><p>Given a stacky fan F and a vector of booleans D representing the distinguished structure, returns a smooth stacky fan where the distinguished rays are independent.</p><p>The algorithm is adapted from Daniel Bergh&#39;s <a href="https://arxiv.org/abs/1409.5713">paper on destackification</a>. In brief, it identifies non-smooth cones containing at least one distinguished ray, finds interior points in those cones, and subdivides at those points through a series of stacky barycentric subdivisions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">
julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 2 5],INPUT_CONES=[[0,1]]);

julia&gt; F=addStackStructure(X,[1,1]);

julia&gt; stackyWeights(BerghA(F,[1,1]))
[ 5 ,  2 ,  5 ,  10 ]

julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 2 5],INPUT_CONES=[[0,1]]);

julia&gt; F=addStackStructure(X,[1,1]);

julia&gt; stackyWeights(BerghA(F,[1,0]));
[ 5 ,  5 ,  1 ,  2 ,  5 ,  10 ]

julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 2 5],INPUT_CONES=[[0,1]]);

julia&gt; F=addStackStructure(X,[1,1]);

julia&gt; stackyWeights(BerghA(F,[0,1]))
[ 1 ,  5 ,  5 ,  2 ,  5 ,  1 ,  5 ,  10 ]

julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[4 1; 7 9],INPUT_CONES=[[0,1]]);

julia&gt; F=addStackStructure(X,[1,1]);

julia&gt; stackyWeights(BerghA(F,[1,0]))
[ 609 ,  29 ,  1 ,  174 ,  29 ,  1740 ,  1218 ,  58 ,  145 ,  1044 ,  1044 ,  290 ,  290 ,  145 ,  406 ,  348 ,  261 ,  14616 ,  14616 ,  609 ,  3480 ,  870 ,  609 ,  174 ,  609 ,  9744 ,  14616 ,  1218 ,  58 ,  145 ,  435 ,  725 ,  1305 ,  1740 ,  6960 ,  3480 ,  870 ,  3480 ,  58464 ,  6090 ,  3480 ,  1392 ,  696 ,  1044 ,  2088 ,  261 ,  174 ,  261 ,  609 ,  406 ,  609 ,  609 ,  406 ,  609 ,  1218 ,  812 ,  1218 ,  2088 ,  261 ,  1044 ,  1160 ,  1740 ,  1740 ,  870 ,  1305 ,  1305 ,  14616 ,  10440 ,  145 ,  435 ,  609 ,  116 ,  580 ,  290 ,  580 ,  1740 ,  3480 ,  3480 ,  261 ,  522 ,  261 ,  522 ,  522 ,  1218 ,  1218 ,  1218 ,  1218 ,  2436 ,  2436 ,  4176 ,  2088 ,  3480 ,  2610 ,  29232 ,  6090 ,  1218 ,  290 ,  145 ,  290 ,  12180 ,  261 ,  522 ]

julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[323 179; 44 135],INPUT_CONES=[[0,1]]);

julia&gt; F=addStackStructure(X,[1,1]);

julia&gt; stackyWeights(BerghA(F,[1,1]))
[ 491602456800 ,  49160245680 ,  294961474080 ,  468192816 ,  12173013216 ,  73038079296 ,  12173013216 ,  97384105728 ,  73038079296 ,  196640982720 ,  131093988480 ,  156064272 ,  936385632 ,  468192816 ,  196640982720 ,  49160245680 ,  9832049136 ,  292152317184 ,  5899229481600 ,  3932819654400 ,  589922948160 ,  393281965440 ,  12173013216 ,  8115342144 ,  12173013216 ,  5899229481600 ,  589922948160 ,  737403685200 ,  51126655507200 ,  292152317184 ,  51126655507200 ,  5899229481600 ,  5899229481600 ,  589922948160 ,  589922948160 ,  196640982720 ,  2949614740800 ,  5899229481600 ,  294961474080 ,  589922948160 ,  196640982720 ,  589922948160 ,  393281965440 ,  936385632 ,  24346026432 ,  24346026432 ,  11798458963200 ,  1179845896320 ,  737403685200 ,  1474807370400 ,  2949614740800 ,  5899229481600 ,  589922948160 ,  11798458963200 ,  1179845896320 ,  2949614740800 ,  1474807370400 ,  5899229481600 ,  102253311014400 ]

julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 3; 4 5 6; 2 3 1],INPUT_CONES=[[0,1,2]]);

julia&gt; F=addStackStructure(X,[1,1,1]);

julia&gt; stackyWeights(BerghA(F,[1,1,1]))
[ 28 ,  21 ,  84 ,  28 ,  84 ,  84 ,  42 ,  84 ,  168 ]

julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 2; 2 1 1; 5 3 9],INPUT_CONES=[[0,1,2]]);

julia&gt; F=addStackStructure(X,[1,1,1]);

julia&gt; stackyWeights(BerghA(F,[1,1,1]))
[ 4 ,  4 ,  8 ,  4 ,  4 ,  8 ]

julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 4 3; 1 5],INPUT_CONES=[[0,1],[1,2]]);

julia&gt; F=addStackStructure(X,[1,1,1]);

julia&gt; stackyWeights(BerghA(F,[1,1,1]))
[ 4 ,  34 ,  6 ,  68 ,  34 ,  68 ,  34 ,  6 ,  12 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L1268-L1335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.stackyBlowup" href="#BerghAlgorithms.stackyBlowup"><code>BerghAlgorithms.stackyBlowup</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stackyBlowup(::StackyFan,::Array{Int64,1},::Array{Int64,1})

Takes a stacky fan sf, a ray excep, and a cone, and subdivides the stacky fan at the given ray. Crucially, the given cone should be the minimal cone containing the exceptional ray. The cone input should be zero-indexed.</code></pre><p>#examples</p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 1 2],INPUT_CONES=[[0,1]]);

julia&gt; F=addStackStructure(X,[2,3]);

julia&gt; stackyWeights(stackyBlowup(F,[0,1],[1,1]))
[ 2 ,  1 ,  3 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L719-L734">source</a></section></article><h2 id="Main-Visualization-Functions"><a class="docs-heading-anchor" href="#Main-Visualization-Functions">Main Visualization Functions</a><a id="Main-Visualization-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Visualization-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.showFan" href="#BerghAlgorithms.showFan"><code>BerghAlgorithms.showFan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">showFan(X::Polymake.BigObjectAllocated)

Plots the input fan as a collection of polygons or polyhedra defined by the input rays and the origin via Plots.jl.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0; 1 0 1; 1 1 0; 1 1 1],INPUT_CONES=[[0,1,2,3]]);

julia&gt; showFan(X);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L1719-L1731">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.showStackyFan" href="#BerghAlgorithms.showStackyFan"><code>BerghAlgorithms.showStackyFan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">showStackyFan(::StackyFan;::Bool=true)

Extends the functionality of showFan to stacky fans. If the stackypoints input is set to true, a red dot is shown at the location of each primitive vector multiplied by its stacky weight.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0; 1 0 1; 1 1 0; 1 1 1],INPUT_CONES=[[0,1,2,3]]);

julia&gt; F=addStackStructure(X,[1,2,2,5]);

julia&gt; showStackyFan(F);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L1752-L1766">source</a></section></article><h2 id="Helper-Functions-for-Fans"><a class="docs-heading-anchor" href="#Helper-Functions-for-Fans">Helper Functions for Fans</a><a id="Helper-Functions-for-Fans-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-Functions-for-Fans" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.findBarycenter" href="#BerghAlgorithms.findBarycenter"><code>BerghAlgorithms.findBarycenter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">findBarycenter(::Union{AbstractSet,AbstractVector},::Polymake.BigObjectAllocated)

Takes a normal toric variety X and a set s corresponding to a subset of rays of X, and outputs a polymake vector corresponding to the barycenter of those rays.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0;1 1; 0 1],INPUT_CONES=[[0,1],[1,2]]);

julia&gt; s=[1,2];

julia&gt; findBarycenter(s,X)
pm::Matrix&lt;pm::Integer&gt;
2 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L273-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.convertBool" href="#BerghAlgorithms.convertBool"><code>BerghAlgorithms.convertBool</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">convertBool(::AbstractVector)</code></pre><p>Takes a column vector of boolean values and converts it to a vector of indices marked &#39;true&#39;.</p><p>#Examples ```jldoctest makeSmoothWithDependencies julia&gt; B=[true true false true]</p><p>julia&gt; convertBool(transpose(B)) [0, 1, 3]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L364-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.getConeRank" href="#BerghAlgorithms.getConeRank"><code>BerghAlgorithms.getConeRank</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getConeRank(::AbstractMatrix,::AbstractVector)</code></pre><p>Takes a matrix and a vector containing indices corresponding to rows of a matrix, and calculates the rank of the matrix consisting only of those rows.</p><p>#Examples ```jldoctest makeSmoothWithDependencies julia&gt; v=[1,2]</p><p>julia&gt; M=[0 1; 1 1; 1 0]</p><p>julia&gt; getConeRank(v,M) 2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L387-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.getDimension" href="#BerghAlgorithms.getDimension"><code>BerghAlgorithms.getDimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getDimension(::Polymake.BigObjectAllocated)</code></pre><p>Returns the ambient dimension of a normal toric variety.</p><p>#Examples ```jldoctest makeSmoothWithDependencies julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT<em>RAYS=[1 0 0;1 2 0;0 0 1;0 1 0; 1 1 1],INPUT</em>CONES=[[0,1,2],[0,2,3,4]])</p><p>julia&gt; getDimension(X) 3</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L407-L418">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.getConeFaces" href="#BerghAlgorithms.getConeFaces"><code>BerghAlgorithms.getConeFaces</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getConeFaces(::Polymake.BigObjectAllocated,::AbstractVector,::AbstractMatrix)</code></pre><p>Takes a fan, its ray matrix, and a vector corresponding to one of its cones, and returns a list of maximal strict faces of that cone.</p><p>#Examples ```jldoctest makeSmoothWithDependencies julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT<em>RAYS=[1 0 0; 1 1 0; 1 0 1; 1 1 1],INPUT</em>CONES=[[0,1,2,3]])</p><p>julia&gt; getConeFaces(X,[1,2,3,4],Array(X.RAYS)) [[ 1 ,  2 ], [ 1 ,  3 ], [ 3 ,  4 ], [ 2 ,  4 ]]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L423-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.slicematrix" href="#BerghAlgorithms.slicematrix"><code>BerghAlgorithms.slicematrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">slicematrix(::AbstractMatrix{&lt;:Number})

Take a two-dimensional matrix and output a list of its row vectors.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A=[1 2; 3 4];

julia&gt; slicematrix(A)
[[ 1 ,  2 ], [ 3 ,  4 ]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L771-L783">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.rowMinors" href="#BerghAlgorithms.rowMinors"><code>BerghAlgorithms.rowMinors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rowMinors(::AbstractMatrix{&lt;:Number},::Union{AbstractSet,AbstractVector})

Identical to slicematrix, except only returns row vectors indexed by a set S.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A=[1 2 3;4 5 6; 7 8 9];

julia&gt; S=Set([1,3]);

julia&gt; rowMinors(A,S)
2×3 LinearAlgebra.Transpose{Int64,Array{Int64,2}}:
 1  2  3
 7  8  9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L788-L804">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.convertIncidenceMatrix" href="#BerghAlgorithms.convertIncidenceMatrix"><code>BerghAlgorithms.convertIncidenceMatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">convertIncidenceMatrix(::Polymake.IncidenceMatrixAllocated{Polymake.NonSymmetric})

Takes a Polymake incidence matrix (e.g., the output of X.MAXIMAL_CONES for a toric variety X) and outputs a list of vectors, with each vector recording the indices marked on a given row of the incidence matrix.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0;1 1; 0 1],INPUT_CONES=[[0,1],[1,2]]);

julia&gt; M=X.MAXIMAL_CONES;

julia&gt; convertIncidenceMatrix(M)
[[ 1 ,  2 ], [ 2 ,  3 ]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L816-L830">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.coneMultiplicity" href="#BerghAlgorithms.coneMultiplicity"><code>BerghAlgorithms.coneMultiplicity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coneMultiplicity(C::Polymake.BigObjectAllocated)

Returns the multiplicity of a polyhedral cone (inputted as a Polymake object): here, the multiplicity is defined as the index of the sublattice generated by the rays of the cone, inside the full integer lattice contained in the linear subspace generated by the edges of the cone.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">
julia&gt; C=Polymake.polytope.Cone(INPUT_RAYS=[1 0; 1 2]);

julia&gt; coneMultiplicity(C)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L848-L861">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.coneConvert" href="#BerghAlgorithms.coneConvert"><code>BerghAlgorithms.coneConvert</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coneConvert(::abstractVector{Int64},::abstractMatrix{Int64})

Takes a matrix where the columns represent rays, and a list of indices, and forms a Polymake cone object generated by the rays corresponding to those indices.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">
julia&gt; typeof(coneConvert([1, 2, 4],[1 0 0; 0 1 0; 0 0 1; 1 1 1]))
Polymake.BigObjectAllocated</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L873-L885">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.getCones" href="#BerghAlgorithms.getCones"><code>BerghAlgorithms.getCones</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getCones(X::Polymake.BigObjectAllocated)

Returns all the cones of a fan X as a list of lists, with each interior list containing the indices of the rays generating a given cone.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0; 1 1 0; 1 0 1; 1 1 ],INPUT_CONES=[[0,1,2,3]]);

julia&gt; getCones(X)
[[ 0 ,  1 ,  2 ,  3 ], [ 0 ,  1 ], [ 0 ,  2 ], [ 2 ,  3 ], [ 1 ,  3 ], [ 0 ], [ 1 ], [ 2 ], [ 3 ]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L892-L905">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.findFaceContainingRay" href="#BerghAlgorithms.findFaceContainingRay"><code>BerghAlgorithms.findFaceContainingRay</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">findFaceContainingRay(::Polymake.BigObjectAllocated,::Array{Int64, 1})</code></pre><p>Given a cone and a ray, finds a maximal proper face of the cone containing that ray.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; C=Polymake.polytope.Cone(INPUT_RAYS=[1 0 0; 1 0 1; 1 1 0; 1 1 1]);

julia&gt; findFaceContainingRay(C,[1,1,1]).RAYS
pm::Matrix&lt;pm::Rational&gt;
1 0 1
1 1 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L917-L932">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.findMinimalCone" href="#BerghAlgorithms.findMinimalCone"><code>BerghAlgorithms.findMinimalCone</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">findMinimalCone(::Polymake.BigObjectAllocated,::Array{Int64,1})</code></pre><p>Given a fan and a ray, finds the minimal cone fo the fan containing the ray.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0 0; 1 0 1 0; 1 1 0 0; 1 1 1 0; 0 0 0 1],INPUT_CONES=[[0,1,2,3,4]]);

julia&gt; findMinimalCone(X,[1,2,0,0])
[1, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L948-L960">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.convertToIncidence" href="#BerghAlgorithms.convertToIncidence"><code>BerghAlgorithms.convertToIncidence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">convertToIncidence(v::Array{Int64,1},l::Int64)</code></pre><p>Returns a vector of length l, with entries of 1 indexed by v and entries of 0 everywhere else.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; convertToIncidence([2,3,5],6)
[ 0 , 1 , 1 , 0 , 1 , 0 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L1041-L1052">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.interiorPoints" href="#BerghAlgorithms.interiorPoints"><code>BerghAlgorithms.interiorPoints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">interiorPoints(::Polymake.BigObjectAllocated)

Finds all interior lattice points contained in the fundamental region of a given cone. When multiple interior lattice points lie along the same ray, only the point closest to the origin is returned. Notably,</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; C=Polymake.polytope.Cone(INPUT_RAYS=[1 2; 2 1]);

julia&gt; interiorPoints(C)
[[ 1 ,  1 ]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L1127-L1140">source</a></section></article><h2 id="Helper-Functions-for-Stacky-Fans"><a class="docs-heading-anchor" href="#Helper-Functions-for-Stacky-Fans">Helper Functions for Stacky Fans</a><a id="Helper-Functions-for-Stacky-Fans-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-Functions-for-Stacky-Fans" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.addStackStructure" href="#BerghAlgorithms.addStackStructure"><code>BerghAlgorithms.addStackStructure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">addStackStructure(::Polymake.BigObjectAllocated, ::Array{Int64, 1})</code></pre><p>Function to generate a stacky fan from a given fan and a set of scalars.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 1 1; 1 2],INPUT_CONES=[[0,1],[1,2]]);

julia&gt; stackyWeights(addStackStructure(X,[2,2,2]))
[ 2 ,  2 ,  2 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L70-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.encode" href="#BerghAlgorithms.encode"><code>BerghAlgorithms.encode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">encode(::Union{Polymake.VectorAllocated{Polymake.Rational},Polymake.VectorAllocated{Polymake.Integer},Vector{Int64}})

Internal function that converts a vector, representing a ray in the fan,</code></pre><p>to a string in order to allow for hashing for the dictionary.</p><p>#Examples</p><pre><code class="language-julia-repl">julia&gt; encode([1,0,2,5])
&quot;1,0,2,5&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L95-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.stackyWeights" href="#BerghAlgorithms.stackyWeights"><code>BerghAlgorithms.stackyWeights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stackyWeights(::StackyFan)

Returns a list of the stacky weights of the rays of the given stacky fan with the same order as the rays of the fan.</code></pre><p>#Examples</p><pre><code class="language-julia-repl">julia&gt; F=makeStackyFan([1 0; 1 1; 1 2; 1 3],[[0,1],[1,2],[2,3]],[1,2,3,4]);

julia&gt; stackyWeights(F)
[ 1 ,  2 ,  3 ,  4 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L111-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.getRayStack" href="#BerghAlgorithms.getRayStack"><code>BerghAlgorithms.getRayStack</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getRayStack(::StackyFan, ::Array{Int64, 1})

Get the scalar associated with a ray in the given stacky fan structure.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; F=makeStackyFan([1 0; 1 1; 1 2; 1 3],[[0,1],[1,2],[2,3]],[1,2,3,4]);

julia&gt; getRayStack(F,[1,2])
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L138-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.rootConstruction" href="#BerghAlgorithms.rootConstruction"><code>BerghAlgorithms.rootConstruction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rootConstruction(::StackyFan, ::Array{Int64, 1})</code></pre><p>Given a fan and a set of scalars corresponding to the rays of the fan, performs a root construction on the fan by multiplying the stack scalars by the given values. </p><p>rootConstruction returns a new StackyFan object, and does not modify the input.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">
julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0;1 1 0;1 0 1;1 1 1],INPUT_CONES=[[0,1,2],[1,2,3]]);

julia&gt; SX = StackyFan(X, [2,3,5,7]);

julia&gt; stackyWeights(rootConstruction(SX, [1, 4, 2, 1]))
[ 2 ,  12 ,  10 ,  7 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L155-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.rootConstructionDistinguished" href="#BerghAlgorithms.rootConstructionDistinguished"><code>BerghAlgorithms.rootConstructionDistinguished</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rootConstructionDistinguished(
    ::StackyFan, 
    ::Polymake.Matrix{Polymake.Rational},
    ::Array{Int64, 1})

Given a fan, a set of distinguished rays, and a set of scalars of equal size,</code></pre><p>performs a root construction on the fan on the distinguished rays by multiplying  the stack scalars by the given values.</p><pre><code class="nohighlight">rootConstructionDistinguished returns a new StackyFan object,</code></pre><p>and does not modify the input.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0;1 1 0;1 0 1;1 1 1],INPUT_CONES=[[0,1,2],[1,2,3]]);

julia&gt; SX = StackyFan(X, [2,3,5,7]);

julia&gt; distinguished = X.RAYS[[2,3],:];

julia&gt; stackyWeights(rootConstructionDistinguished(SX, distinguished, [4, 2]))
[ 2 ,  12 ,  10 ,  7 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L219-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.rootConstructionDistinguishedIndices" href="#BerghAlgorithms.rootConstructionDistinguishedIndices"><code>BerghAlgorithms.rootConstructionDistinguishedIndices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rootConstructionDistinguishedIndices(::StackyFan, ::Array{Int64, 1}, ::Array{Int64, 1})

Given a fan, the indices of the distinguished rays in the fan rays (as an incidence matrix), and</code></pre><p>a set of scalars corresponding to the rays of the fan, performs a root  construction on the fan by multiplying the stack scalars by the given values. </p><pre><code class="nohighlight">rootConstructionDistinguishedIndices returns a new StackyFan object,</code></pre><p>and does not modify the input.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0 0;1 1 0;1 0 1;1 1 1],INPUT_CONES=[[0,1,2],[1,2,3]]);

julia&gt; SX = StackyFan(X, [2,3,5,7]);

julia&gt; stackyWeights(rootConstructionDistinguishedIndices(SX, [0,1,1,0], [4, 2, 1, 3]))
[ 2 ,  6 ,  5 ,  7 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L183-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.findStackyBarycenter" href="#BerghAlgorithms.findStackyBarycenter"><code>BerghAlgorithms.findStackyBarycenter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">findStackyBarycenter(::Union{AbstractSet,AbstractVector},::StackyFan)

Takes a stacky fan SX and a set s corresponding to a subset of rays of SX, calculates the &#39;stacky rays&#39; corresponding to those rays (the rays times their stacky values), and find the barycenter of the stacky rays.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 1 2],INPUT_CONES=[[0,1]]);

julia&gt; F=addStackStructure(X,[2,3]);

julia&gt; findStackyBarycenter([1,2],F)
[ 5 ,  6 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L312-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.findStackyRayMatrix" href="#BerghAlgorithms.findStackyRayMatrix"><code>BerghAlgorithms.findStackyRayMatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">findStackyRayMatrix(::StackyFan)

Outputs the ray matrix of the given stacky fan, such that each primitive ray is multiplied by its stacky weights.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 2 3; 1 5],INPUT_CONES=[[0,1],[1,2]]);

julia&gt; F=addStackStructure(X,[1,2,3]);

julia&gt; findStackyRayMatrix(F)
3×2 Matrix{Int64}:
 1   0
 4   6
 3  15</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L340-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.getConesPolymake" href="#BerghAlgorithms.getConesPolymake"><code>BerghAlgorithms.getConesPolymake</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getConesPolymake(sf::StackyFan)

Returns a list of cones of a stacky fan, with the cones represented as polymake objects.</code></pre><p>#Examples</p><pre><code class="language-julia-repl">julia&gt; F=makeStackyFan([1 0; 1 1; 1 2; 1 3],[[0,1],[1,2],[2,3]])
    
julia&gt; getConesPolymake(F)[1].RAYS
pm::Matrix&lt;pm::Rational&gt;
1 0
1 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L748-L762">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.distinguishedAndIntPoint" href="#BerghAlgorithms.distinguishedAndIntPoint"><code>BerghAlgorithms.distinguishedAndIntPoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    distinguishedAndIntPoint(::Array{Int64,1},::Array{Int64,2},::Array{Int64,1})

Calculates if the cone formed by a subset of rays in rayMatrix indexed by the entries of cone, and with a distinguished structure given by the incidence vector dist, both contains at least one distinguished ray and contains a proper interior point.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; distinguishedAndMultiplicity([1,2,4],[1 0 0; 1 2 0;2 1 3; 1 0 3],[1,0,0,0])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L1016-L1026">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.compareCones" href="#BerghAlgorithms.compareCones"><code>BerghAlgorithms.compareCones</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compareCones(::Array{Int64,1},::Array{Int64,1},::Array{Int64,2},::Array{Int64,1})

Takes in two cones (in index vector notation), a ray matrix, and a incidence vector of distinguished rays. If the cones do not have an equal number of distinguished rays, returns the difference between the two values. Otherwise, returns the difference in the cone multiplicities.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; compareCones([1,2],[2,3],[1 0 0; 0 1 0; 0 0 1],[1,1,0])
1

julia&gt; compareCones([1,2],[1,3],[1 0;1 2;1 -1],[1,1,1])
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L1065-L1079">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.extremalCones" href="#BerghAlgorithms.extremalCones"><code>BerghAlgorithms.extremalCones</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">extremalCones(::Array{Array{Int64,1},1},::Array{Int64,2},::Array{Int64,1})

Takes a list of vectors representing cones in a fan, a ray matrix, and a vector representing the distinguished rays as 0 or 1 values, and calculates the cones that are maximal with respect to (first) the number of non-distinguished rays and (second) the multiplicity of the cone. In Bergh&#39;s algorithm A (where this ordering is used), the input S will consist only of those cones containing at least one distinguished ray and at least one interior point.</code></pre><p>#Examples</p><pre><code class="language-julia-repl">julia&gt; extremalCones([[1,2],[2,3],[3,4]],[1 0;1 2; 1 5; 1 8],[0,1,1,0])
[[ 3 ,  4 ]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L1097-L1108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.minimalByLex" href="#BerghAlgorithms.minimalByLex"><code>BerghAlgorithms.minimalByLex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">minimalByLex(::Array{Array{Int64,1},1})

Given a list of vectors of equal length, returns the minimal vector with respect to lexicographic ordering.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A=[[1,1,1],[2,1,3],[0,5,4]];

julia&gt; minimalByLex(A)
[ 0 ,  5 ,  4 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L1178-L1191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.minimalByDist" href="#BerghAlgorithms.minimalByDist"><code>BerghAlgorithms.minimalByDist</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">minimalByDist(::Array{Array{Int64,1},1},::Array{Int64,1})

Given a list of vectors (representing rays as weighted sums of other rays) and a vector of 0&#39;s and 1&#39;s representing non-distinguished and distinguished indices, returns a vector from the list such that the sum of the entries corresponding to distinguished indices is minimized.</code></pre><p>#Examples</p><pre><code class="language-julia-repl">julia&gt; minimalByDist([[0,1,5,7],[3,3,2,2],[8,5,3,6],[2,1,1,10]],[0,1,1,0])
[ 3 , 3 , 2 , 2 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L1210-L1221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.coneRayDecomposition" href="#BerghAlgorithms.coneRayDecomposition"><code>BerghAlgorithms.coneRayDecomposition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coneRayDecomposition(::Array{Int64,1},::Array{Int64,2},::Array{Int64,1},::Array{Int64,1})

This function takes in a cone (a vector of indices of cone generators in rayMatrix), a ray, and a stacky structure for rayMatrix. It first multiplies all generators of the cone by their stacky values, and then finds an expression for the ray as a sum of these stacky generators. The output is a vector of coefficients of the above representation in terms of the rays in rayMatrix, with zeros as coefficients for all rays not in the given cone.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; coneRayDecomposition([1,2,3],[3 5 7; 8 16 9;2 1 3;1 1 1],[2,2,3],[1,1,1,1])
[ 6 ,  5 ,  52 ,  0 ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L1235-L1245">source</a></section></article><h2 id="Visualization-Helper-Functions"><a class="docs-heading-anchor" href="#Visualization-Helper-Functions">Visualization Helper Functions</a><a id="Visualization-Helper-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization-Helper-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.plot3dSimpCone" href="#BerghAlgorithms.plot3dSimpCone"><code>BerghAlgorithms.plot3dSimpCone</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plot3dSimpCone(::Array{Array{Int64,1},1})

Give a list of three 3-dimensional vectors, plots the polygon defined by those vectors and the origin via Plots.jl.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; plot3dSimpCone([[1,0,0],[0,1,0],[0,0,1]]);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L1508-L1518">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.plot2dCone" href="#BerghAlgorithms.plot2dCone"><code>BerghAlgorithms.plot2dCone</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plot2dCone(::Array{Array{Int64,1},1})

Given a list of two 2-dimesnional vectors, plots the polygon defined by those vectors and the origin via Plots.jl.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; plot2dCone([[1,0],[0,1]]);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L1547-L1557">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.showSimpFan" href="#BerghAlgorithms.showSimpFan"><code>BerghAlgorithms.showSimpFan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">showSimpFan(X::Polymake.BigObjectAllocated)

Plots the input simplicial fan as a collection of polygons or polyhedra defined by the input rays and the origin via Plots.jl.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 2 5],INPUT_CONES=[[0,1]]);

julia&gt; showSimpFan(X);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L1575-L1587">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.showSimpStackyFan" href="#BerghAlgorithms.showSimpStackyFan"><code>BerghAlgorithms.showSimpStackyFan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">showSimpStackyFan(::StackyFan;::Bool=true)

Extends the functionality of showSimpFan to stacky simplicial fans. If the stackypoints input is set to true, a red dot is shown at the location of each primitive vector multiplied by its stacky weight.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X=Polymake.fulton.NormalToricVariety(INPUT_RAYS=[1 0; 2 5],INPUT_CONES=[[0,1]]);

julia&gt; F=addStackStructure(X,[1,2]);

julia&gt; showSimpStackyFan(F)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L1607-L1621">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.coneVectorOrder" href="#BerghAlgorithms.coneVectorOrder"><code>BerghAlgorithms.coneVectorOrder</code></a> — <span class="docstring-category">Function</span></header><section><div><p><strong>Examples</strong></p><pre><code class="nohighlight">coneVectorOrder(::Polymake.BigObjectAllocated)

Takes a polyhedral cone in 2 or 3 dimensions and outputs a list of its defining rays, arranged in counterclockwise order around the exterior of the cone.</code></pre><p><strong>Exampels</strong></p><pre><code class="language-julia-repl">julia&gt; C=Polymake.polytope.Cone(INPUT_RAYS=[[1 0 0; 1 0 1; 0 1 1; 1 1 1]]);

julia&gt; coneVectorOrder(C)
[[1
, 1, 0], [1, 1, 1], [1, 0, 1], [1, 0, 0]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L1654-L1672">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BerghAlgorithms.plot3dCone" href="#BerghAlgorithms.plot3dCone"><code>BerghAlgorithms.plot3dCone</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plot3dCone(::Array{Array{Int64,1},1})

Plots the 3-dimensional cone defined by the given list of rays. The input rays are assumed to be in counterclockwise or clockwise order around the cone; coneVectorOrder() can be used to obtain this ordering from an arbitrary cone.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; plot3dCone([[1,1,0],[1,1,1],[1,0,1],[1,0,0]]);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nbenabla/destackification/blob/8cea1e44fa8dccb1bdc5226c238f40e4eba99cbb/BerghAlgorithms/src/StackyFan.jl#L1684-L1694">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 19 June 2021 15:25">Saturday 19 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
